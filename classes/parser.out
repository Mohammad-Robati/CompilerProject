Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI_COLON declist block SEMI_COLON
Rule 2     program -> PROGRAM ID SEMI_COLON block SEMI_COLON
Rule 3     declist -> dec
Rule 4     declist -> declist dec
Rule 5     dec -> vardec
Rule 6     dec -> procdec
Rule 7     dec -> funcdec
Rule 8     type -> INT
Rule 9     type -> REAL
Rule 10    type -> BOOL
Rule 11    iddec -> ID
Rule 12    iddec -> ID ASSIGN exp
Rule 13    idlist -> iddec
Rule 14    idlist -> idlist SEPARATOR iddec
Rule 15    vardec -> type idlist SEMI_COLON
Rule 16    procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
Rule 17    procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
Rule 18    funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
Rule 19    funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
Rule 20    paramdecs -> paramdec
Rule 21    paramdecs -> paramdecs SEMI_COLON paramdec
Rule 22    paramdec -> type paramlist
Rule 23    paramlist -> ID
Rule 24    paramlist -> paramlist SEPARATOR ID
Rule 25    block -> BEGIN stmtlist END
Rule 26    block -> stmt
Rule 27    stmtlist -> stmt
Rule 28    stmtlist -> stmtlist SEMI_COLON stmt
Rule 29    lvalue -> ID
Rule 30    assignstmt -> lvalue ASSIGN exp
Rule 31    stmt -> assignstmt
Rule 32    stmt -> IF controlifexp THEN block
Rule 33    stmt -> IF controlifexp THEN block ELSE controlelse block
Rule 34    controlifexp -> exp
Rule 35    controlelse -> <empty>
Rule 36    stmt -> WHILE controlwhileexp DO block
Rule 37    controlwhileexp -> exp
Rule 38    stmt -> FOR assignstmt TO controlforupexp DO block
Rule 39    stmt -> FOR assignstmt DOWNTO controlfordownexp DO block
Rule 40    controlforupexp -> exp
Rule 41    controlfordownexp -> exp
Rule 42    stmt -> CASE controlcaseexp caseelement END
Rule 43    controlcaseexp -> exp
Rule 44    caseelement -> case COLON caseelementcontrol block SEMI_COLON
Rule 45    caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON
Rule 46    caseelementcontrol -> <empty>
Rule 47    case -> INTEGER
Rule 48    stmt -> RETURN exp
Rule 49    stmt -> exp
Rule 50    exp -> exp SUM exp
Rule 51    exp -> exp SUB exp
Rule 52    exp -> exp MUL exp
Rule 53    exp -> exp DIV exp
Rule 54    exp -> exp AND exp
Rule 55    exp -> exp OR exp
Rule 56    exp -> exp NE exp
Rule 57    exp -> exp EQ exp
Rule 58    exp -> exp LT exp
Rule 59    exp -> exp GT exp
Rule 60    exp -> exp LE exp
Rule 61    exp -> exp GE exp
Rule 62    exp -> OPEN_PAREN exp CLOSE_PAREN
Rule 63    exp -> REALNUMBER
Rule 64    exp -> INTEGER
Rule 65    exp -> TRUE
Rule 66    exp -> FALSE
Rule 67    exp -> lvalue
Rule 68    exp -> ID OPEN_PAREN explist CLOSE_PAREN
Rule 69    explist -> exp
Rule 70    explist -> explist SEPARATOR exp

Terminals, with rules where they appear

AND                  : 54
ASSIGN               : 12 30
BEGIN                : 25
BOOL                 : 10
CASE                 : 42
CLOSE_PAREN          : 16 17 18 19 62 68
COLON                : 18 19 44 45
DIV                  : 53
DO                   : 36 38 39
DOWNTO               : 39
ELSE                 : 33
END                  : 25 42
EQ                   : 57
FALSE                : 66
FOR                  : 38 39
FUNCTION             : 18 19
GE                   : 61
GT                   : 59
ID                   : 1 2 11 12 16 17 18 19 23 24 29 68
IF                   : 32 33
INT                  : 8
INTEGER              : 47 64
LE                   : 60
LT                   : 58
MUL                  : 52
NE                   : 56
OPEN_PAREN           : 16 17 18 19 62 68
OR                   : 55
PROCEDURE            : 16 17
PROGRAM              : 1 2
REAL                 : 9
REALNUMBER           : 63
RETURN               : 48
SEMI_COLON           : 1 1 2 2 15 16 17 18 19 21 28 44 45
SEPARATOR            : 14 24 70
SUB                  : 51
SUM                  : 50
THEN                 : 32 33
TO                   : 38
TRUE                 : 65
WHILE                : 36
error                : 

Nonterminals, with rules where they appear

assignstmt           : 31 38 39
block                : 1 2 16 17 18 19 32 33 33 36 38 39 44 45
case                 : 44 45
caseelement          : 42 45
caseelementcontrol   : 44 45
controlcaseexp       : 42
controlelse          : 33
controlfordownexp    : 39
controlforupexp      : 38
controlifexp         : 32 33
controlwhileexp      : 36
dec                  : 3 4
declist              : 1 4 16 18
exp                  : 12 30 34 37 40 41 43 48 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 69 70
explist              : 68 70
funcdec              : 7
iddec                : 13 14
idlist               : 14 15
lvalue               : 30 67
paramdec             : 20 21
paramdecs            : 16 17 18 19 21
paramlist            : 22 24
procdec              : 6
program              : 0
stmt                 : 26 27 28
stmtlist             : 25 28
type                 : 15 18 19 22
vardec               : 5

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI_COLON declist block SEMI_COLON
    (2) program -> . PROGRAM ID SEMI_COLON block SEMI_COLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMI_COLON declist block SEMI_COLON
    (2) program -> PROGRAM . ID SEMI_COLON block SEMI_COLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMI_COLON declist block SEMI_COLON
    (2) program -> PROGRAM ID . SEMI_COLON block SEMI_COLON

    SEMI_COLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI_COLON . declist block SEMI_COLON
    (2) program -> PROGRAM ID SEMI_COLON . block SEMI_COLON
    (3) declist -> . dec
    (4) declist -> . declist dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    declist                        shift and go to state 6
    block                          shift and go to state 7
    dec                            shift and go to state 8
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    type                           shift and go to state 21
    lvalue                         shift and go to state 25

state 5

    (68) exp -> ID . OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> ID .

    OPEN_PAREN      shift and go to state 33
    ASSIGN          reduce using rule 29 (lvalue -> ID .)
    SUM             reduce using rule 29 (lvalue -> ID .)
    SUB             reduce using rule 29 (lvalue -> ID .)
    MUL             reduce using rule 29 (lvalue -> ID .)
    DIV             reduce using rule 29 (lvalue -> ID .)
    AND             reduce using rule 29 (lvalue -> ID .)
    OR              reduce using rule 29 (lvalue -> ID .)
    NE              reduce using rule 29 (lvalue -> ID .)
    EQ              reduce using rule 29 (lvalue -> ID .)
    LT              reduce using rule 29 (lvalue -> ID .)
    GT              reduce using rule 29 (lvalue -> ID .)
    LE              reduce using rule 29 (lvalue -> ID .)
    GE              reduce using rule 29 (lvalue -> ID .)
    SEMI_COLON      reduce using rule 29 (lvalue -> ID .)
    END             reduce using rule 29 (lvalue -> ID .)
    THEN            reduce using rule 29 (lvalue -> ID .)
    DO              reduce using rule 29 (lvalue -> ID .)
    INTEGER         reduce using rule 29 (lvalue -> ID .)
    ELSE            reduce using rule 29 (lvalue -> ID .)
    CLOSE_PAREN     reduce using rule 29 (lvalue -> ID .)
    SEPARATOR       reduce using rule 29 (lvalue -> ID .)
    TO              reduce using rule 29 (lvalue -> ID .)
    DOWNTO          reduce using rule 29 (lvalue -> ID .)


state 6

    (1) program -> PROGRAM ID SEMI_COLON declist . block SEMI_COLON
    (4) declist -> declist . dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    block                          shift and go to state 34
    dec                            shift and go to state 35
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    type                           shift and go to state 21
    lvalue                         shift and go to state 25

state 7

    (2) program -> PROGRAM ID SEMI_COLON block . SEMI_COLON

    SEMI_COLON      shift and go to state 36


state 8

    (3) declist -> dec .

    BEGIN           reduce using rule 3 (declist -> dec .)
    IF              reduce using rule 3 (declist -> dec .)
    WHILE           reduce using rule 3 (declist -> dec .)
    FOR             reduce using rule 3 (declist -> dec .)
    CASE            reduce using rule 3 (declist -> dec .)
    RETURN          reduce using rule 3 (declist -> dec .)
    PROCEDURE       reduce using rule 3 (declist -> dec .)
    FUNCTION        reduce using rule 3 (declist -> dec .)
    OPEN_PAREN      reduce using rule 3 (declist -> dec .)
    REALNUMBER      reduce using rule 3 (declist -> dec .)
    INTEGER         reduce using rule 3 (declist -> dec .)
    TRUE            reduce using rule 3 (declist -> dec .)
    FALSE           reduce using rule 3 (declist -> dec .)
    ID              reduce using rule 3 (declist -> dec .)
    INT             reduce using rule 3 (declist -> dec .)
    REAL            reduce using rule 3 (declist -> dec .)
    BOOL            reduce using rule 3 (declist -> dec .)


state 9

    (25) block -> BEGIN . stmtlist END
    (27) stmtlist -> . stmt
    (28) stmtlist -> . stmtlist SEMI_COLON stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    stmtlist                       shift and go to state 37
    stmt                           shift and go to state 38
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 10

    (26) block -> stmt .

    SEMI_COLON      reduce using rule 26 (block -> stmt .)
    ELSE            reduce using rule 26 (block -> stmt .)
    END             reduce using rule 26 (block -> stmt .)


state 11

    (5) dec -> vardec .

    BEGIN           reduce using rule 5 (dec -> vardec .)
    IF              reduce using rule 5 (dec -> vardec .)
    WHILE           reduce using rule 5 (dec -> vardec .)
    FOR             reduce using rule 5 (dec -> vardec .)
    CASE            reduce using rule 5 (dec -> vardec .)
    RETURN          reduce using rule 5 (dec -> vardec .)
    PROCEDURE       reduce using rule 5 (dec -> vardec .)
    FUNCTION        reduce using rule 5 (dec -> vardec .)
    OPEN_PAREN      reduce using rule 5 (dec -> vardec .)
    REALNUMBER      reduce using rule 5 (dec -> vardec .)
    INTEGER         reduce using rule 5 (dec -> vardec .)
    TRUE            reduce using rule 5 (dec -> vardec .)
    FALSE           reduce using rule 5 (dec -> vardec .)
    ID              reduce using rule 5 (dec -> vardec .)
    INT             reduce using rule 5 (dec -> vardec .)
    REAL            reduce using rule 5 (dec -> vardec .)
    BOOL            reduce using rule 5 (dec -> vardec .)


state 12

    (6) dec -> procdec .

    BEGIN           reduce using rule 6 (dec -> procdec .)
    IF              reduce using rule 6 (dec -> procdec .)
    WHILE           reduce using rule 6 (dec -> procdec .)
    FOR             reduce using rule 6 (dec -> procdec .)
    CASE            reduce using rule 6 (dec -> procdec .)
    RETURN          reduce using rule 6 (dec -> procdec .)
    PROCEDURE       reduce using rule 6 (dec -> procdec .)
    FUNCTION        reduce using rule 6 (dec -> procdec .)
    OPEN_PAREN      reduce using rule 6 (dec -> procdec .)
    REALNUMBER      reduce using rule 6 (dec -> procdec .)
    INTEGER         reduce using rule 6 (dec -> procdec .)
    TRUE            reduce using rule 6 (dec -> procdec .)
    FALSE           reduce using rule 6 (dec -> procdec .)
    ID              reduce using rule 6 (dec -> procdec .)
    INT             reduce using rule 6 (dec -> procdec .)
    REAL            reduce using rule 6 (dec -> procdec .)
    BOOL            reduce using rule 6 (dec -> procdec .)


state 13

    (7) dec -> funcdec .

    BEGIN           reduce using rule 7 (dec -> funcdec .)
    IF              reduce using rule 7 (dec -> funcdec .)
    WHILE           reduce using rule 7 (dec -> funcdec .)
    FOR             reduce using rule 7 (dec -> funcdec .)
    CASE            reduce using rule 7 (dec -> funcdec .)
    RETURN          reduce using rule 7 (dec -> funcdec .)
    PROCEDURE       reduce using rule 7 (dec -> funcdec .)
    FUNCTION        reduce using rule 7 (dec -> funcdec .)
    OPEN_PAREN      reduce using rule 7 (dec -> funcdec .)
    REALNUMBER      reduce using rule 7 (dec -> funcdec .)
    INTEGER         reduce using rule 7 (dec -> funcdec .)
    TRUE            reduce using rule 7 (dec -> funcdec .)
    FALSE           reduce using rule 7 (dec -> funcdec .)
    ID              reduce using rule 7 (dec -> funcdec .)
    INT             reduce using rule 7 (dec -> funcdec .)
    REAL            reduce using rule 7 (dec -> funcdec .)
    BOOL            reduce using rule 7 (dec -> funcdec .)


state 14

    (31) stmt -> assignstmt .

    SEMI_COLON      reduce using rule 31 (stmt -> assignstmt .)
    END             reduce using rule 31 (stmt -> assignstmt .)
    ELSE            reduce using rule 31 (stmt -> assignstmt .)


state 15

    (32) stmt -> IF . controlifexp THEN block
    (33) stmt -> IF . controlifexp THEN block ELSE controlelse block
    (34) controlifexp -> . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    controlifexp                   shift and go to state 39
    exp                            shift and go to state 40
    lvalue                         shift and go to state 41

state 16

    (36) stmt -> WHILE . controlwhileexp DO block
    (37) controlwhileexp -> . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    controlwhileexp                shift and go to state 42
    exp                            shift and go to state 43
    lvalue                         shift and go to state 41

state 17

    (38) stmt -> FOR . assignstmt TO controlforupexp DO block
    (39) stmt -> FOR . assignstmt DOWNTO controlfordownexp DO block
    (30) assignstmt -> . lvalue ASSIGN exp
    (29) lvalue -> . ID

    ID              shift and go to state 46

    assignstmt                     shift and go to state 44
    lvalue                         shift and go to state 45

state 18

    (42) stmt -> CASE . controlcaseexp caseelement END
    (43) controlcaseexp -> . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    controlcaseexp                 shift and go to state 47
    exp                            shift and go to state 48
    lvalue                         shift and go to state 41

state 19

    (48) stmt -> RETURN . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 49
    lvalue                         shift and go to state 41

state 20

    (49) stmt -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 49 (stmt -> exp .)
    END             reduce using rule 49 (stmt -> exp .)
    ELSE            reduce using rule 49 (stmt -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 21

    (15) vardec -> type . idlist SEMI_COLON
    (13) idlist -> . iddec
    (14) idlist -> . idlist SEPARATOR iddec
    (11) iddec -> . ID
    (12) iddec -> . ID ASSIGN exp

    ID              shift and go to state 64

    idlist                         shift and go to state 62
    iddec                          shift and go to state 63

state 22

    (16) procdec -> PROCEDURE . ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> PROCEDURE . ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON

    ID              shift and go to state 65


state 23

    (62) exp -> OPEN_PAREN . exp CLOSE_PAREN
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 66
    lvalue                         shift and go to state 41

state 24

    (18) funcdec -> FUNCTION . ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> FUNCTION . ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON

    ID              shift and go to state 67


state 25

    (30) assignstmt -> lvalue . ASSIGN exp
    (67) exp -> lvalue .

    ASSIGN          shift and go to state 68
    SUM             reduce using rule 67 (exp -> lvalue .)
    SUB             reduce using rule 67 (exp -> lvalue .)
    MUL             reduce using rule 67 (exp -> lvalue .)
    DIV             reduce using rule 67 (exp -> lvalue .)
    AND             reduce using rule 67 (exp -> lvalue .)
    OR              reduce using rule 67 (exp -> lvalue .)
    NE              reduce using rule 67 (exp -> lvalue .)
    EQ              reduce using rule 67 (exp -> lvalue .)
    LT              reduce using rule 67 (exp -> lvalue .)
    GT              reduce using rule 67 (exp -> lvalue .)
    LE              reduce using rule 67 (exp -> lvalue .)
    GE              reduce using rule 67 (exp -> lvalue .)
    SEMI_COLON      reduce using rule 67 (exp -> lvalue .)
    END             reduce using rule 67 (exp -> lvalue .)
    ELSE            reduce using rule 67 (exp -> lvalue .)


state 26

    (63) exp -> REALNUMBER .

    SUM             reduce using rule 63 (exp -> REALNUMBER .)
    SUB             reduce using rule 63 (exp -> REALNUMBER .)
    MUL             reduce using rule 63 (exp -> REALNUMBER .)
    DIV             reduce using rule 63 (exp -> REALNUMBER .)
    AND             reduce using rule 63 (exp -> REALNUMBER .)
    OR              reduce using rule 63 (exp -> REALNUMBER .)
    NE              reduce using rule 63 (exp -> REALNUMBER .)
    EQ              reduce using rule 63 (exp -> REALNUMBER .)
    LT              reduce using rule 63 (exp -> REALNUMBER .)
    GT              reduce using rule 63 (exp -> REALNUMBER .)
    LE              reduce using rule 63 (exp -> REALNUMBER .)
    GE              reduce using rule 63 (exp -> REALNUMBER .)
    SEMI_COLON      reduce using rule 63 (exp -> REALNUMBER .)
    END             reduce using rule 63 (exp -> REALNUMBER .)
    THEN            reduce using rule 63 (exp -> REALNUMBER .)
    DO              reduce using rule 63 (exp -> REALNUMBER .)
    INTEGER         reduce using rule 63 (exp -> REALNUMBER .)
    ELSE            reduce using rule 63 (exp -> REALNUMBER .)
    CLOSE_PAREN     reduce using rule 63 (exp -> REALNUMBER .)
    SEPARATOR       reduce using rule 63 (exp -> REALNUMBER .)
    TO              reduce using rule 63 (exp -> REALNUMBER .)
    DOWNTO          reduce using rule 63 (exp -> REALNUMBER .)


state 27

    (64) exp -> INTEGER .

    SUM             reduce using rule 64 (exp -> INTEGER .)
    SUB             reduce using rule 64 (exp -> INTEGER .)
    MUL             reduce using rule 64 (exp -> INTEGER .)
    DIV             reduce using rule 64 (exp -> INTEGER .)
    AND             reduce using rule 64 (exp -> INTEGER .)
    OR              reduce using rule 64 (exp -> INTEGER .)
    NE              reduce using rule 64 (exp -> INTEGER .)
    EQ              reduce using rule 64 (exp -> INTEGER .)
    LT              reduce using rule 64 (exp -> INTEGER .)
    GT              reduce using rule 64 (exp -> INTEGER .)
    LE              reduce using rule 64 (exp -> INTEGER .)
    GE              reduce using rule 64 (exp -> INTEGER .)
    SEMI_COLON      reduce using rule 64 (exp -> INTEGER .)
    END             reduce using rule 64 (exp -> INTEGER .)
    THEN            reduce using rule 64 (exp -> INTEGER .)
    DO              reduce using rule 64 (exp -> INTEGER .)
    INTEGER         reduce using rule 64 (exp -> INTEGER .)
    ELSE            reduce using rule 64 (exp -> INTEGER .)
    CLOSE_PAREN     reduce using rule 64 (exp -> INTEGER .)
    SEPARATOR       reduce using rule 64 (exp -> INTEGER .)
    TO              reduce using rule 64 (exp -> INTEGER .)
    DOWNTO          reduce using rule 64 (exp -> INTEGER .)


state 28

    (65) exp -> TRUE .

    SUM             reduce using rule 65 (exp -> TRUE .)
    SUB             reduce using rule 65 (exp -> TRUE .)
    MUL             reduce using rule 65 (exp -> TRUE .)
    DIV             reduce using rule 65 (exp -> TRUE .)
    AND             reduce using rule 65 (exp -> TRUE .)
    OR              reduce using rule 65 (exp -> TRUE .)
    NE              reduce using rule 65 (exp -> TRUE .)
    EQ              reduce using rule 65 (exp -> TRUE .)
    LT              reduce using rule 65 (exp -> TRUE .)
    GT              reduce using rule 65 (exp -> TRUE .)
    LE              reduce using rule 65 (exp -> TRUE .)
    GE              reduce using rule 65 (exp -> TRUE .)
    SEMI_COLON      reduce using rule 65 (exp -> TRUE .)
    END             reduce using rule 65 (exp -> TRUE .)
    THEN            reduce using rule 65 (exp -> TRUE .)
    DO              reduce using rule 65 (exp -> TRUE .)
    INTEGER         reduce using rule 65 (exp -> TRUE .)
    ELSE            reduce using rule 65 (exp -> TRUE .)
    CLOSE_PAREN     reduce using rule 65 (exp -> TRUE .)
    SEPARATOR       reduce using rule 65 (exp -> TRUE .)
    TO              reduce using rule 65 (exp -> TRUE .)
    DOWNTO          reduce using rule 65 (exp -> TRUE .)


state 29

    (66) exp -> FALSE .

    SUM             reduce using rule 66 (exp -> FALSE .)
    SUB             reduce using rule 66 (exp -> FALSE .)
    MUL             reduce using rule 66 (exp -> FALSE .)
    DIV             reduce using rule 66 (exp -> FALSE .)
    AND             reduce using rule 66 (exp -> FALSE .)
    OR              reduce using rule 66 (exp -> FALSE .)
    NE              reduce using rule 66 (exp -> FALSE .)
    EQ              reduce using rule 66 (exp -> FALSE .)
    LT              reduce using rule 66 (exp -> FALSE .)
    GT              reduce using rule 66 (exp -> FALSE .)
    LE              reduce using rule 66 (exp -> FALSE .)
    GE              reduce using rule 66 (exp -> FALSE .)
    SEMI_COLON      reduce using rule 66 (exp -> FALSE .)
    END             reduce using rule 66 (exp -> FALSE .)
    THEN            reduce using rule 66 (exp -> FALSE .)
    DO              reduce using rule 66 (exp -> FALSE .)
    INTEGER         reduce using rule 66 (exp -> FALSE .)
    ELSE            reduce using rule 66 (exp -> FALSE .)
    CLOSE_PAREN     reduce using rule 66 (exp -> FALSE .)
    SEPARATOR       reduce using rule 66 (exp -> FALSE .)
    TO              reduce using rule 66 (exp -> FALSE .)
    DOWNTO          reduce using rule 66 (exp -> FALSE .)


state 30

    (8) type -> INT .

    ID              reduce using rule 8 (type -> INT .)
    BEGIN           reduce using rule 8 (type -> INT .)
    IF              reduce using rule 8 (type -> INT .)
    WHILE           reduce using rule 8 (type -> INT .)
    FOR             reduce using rule 8 (type -> INT .)
    CASE            reduce using rule 8 (type -> INT .)
    RETURN          reduce using rule 8 (type -> INT .)
    PROCEDURE       reduce using rule 8 (type -> INT .)
    FUNCTION        reduce using rule 8 (type -> INT .)
    OPEN_PAREN      reduce using rule 8 (type -> INT .)
    REALNUMBER      reduce using rule 8 (type -> INT .)
    INTEGER         reduce using rule 8 (type -> INT .)
    TRUE            reduce using rule 8 (type -> INT .)
    FALSE           reduce using rule 8 (type -> INT .)
    INT             reduce using rule 8 (type -> INT .)
    REAL            reduce using rule 8 (type -> INT .)
    BOOL            reduce using rule 8 (type -> INT .)


state 31

    (9) type -> REAL .

    ID              reduce using rule 9 (type -> REAL .)
    BEGIN           reduce using rule 9 (type -> REAL .)
    IF              reduce using rule 9 (type -> REAL .)
    WHILE           reduce using rule 9 (type -> REAL .)
    FOR             reduce using rule 9 (type -> REAL .)
    CASE            reduce using rule 9 (type -> REAL .)
    RETURN          reduce using rule 9 (type -> REAL .)
    PROCEDURE       reduce using rule 9 (type -> REAL .)
    FUNCTION        reduce using rule 9 (type -> REAL .)
    OPEN_PAREN      reduce using rule 9 (type -> REAL .)
    REALNUMBER      reduce using rule 9 (type -> REAL .)
    INTEGER         reduce using rule 9 (type -> REAL .)
    TRUE            reduce using rule 9 (type -> REAL .)
    FALSE           reduce using rule 9 (type -> REAL .)
    INT             reduce using rule 9 (type -> REAL .)
    REAL            reduce using rule 9 (type -> REAL .)
    BOOL            reduce using rule 9 (type -> REAL .)


state 32

    (10) type -> BOOL .

    ID              reduce using rule 10 (type -> BOOL .)
    BEGIN           reduce using rule 10 (type -> BOOL .)
    IF              reduce using rule 10 (type -> BOOL .)
    WHILE           reduce using rule 10 (type -> BOOL .)
    FOR             reduce using rule 10 (type -> BOOL .)
    CASE            reduce using rule 10 (type -> BOOL .)
    RETURN          reduce using rule 10 (type -> BOOL .)
    PROCEDURE       reduce using rule 10 (type -> BOOL .)
    FUNCTION        reduce using rule 10 (type -> BOOL .)
    OPEN_PAREN      reduce using rule 10 (type -> BOOL .)
    REALNUMBER      reduce using rule 10 (type -> BOOL .)
    INTEGER         reduce using rule 10 (type -> BOOL .)
    TRUE            reduce using rule 10 (type -> BOOL .)
    FALSE           reduce using rule 10 (type -> BOOL .)
    INT             reduce using rule 10 (type -> BOOL .)
    REAL            reduce using rule 10 (type -> BOOL .)
    BOOL            reduce using rule 10 (type -> BOOL .)


state 33

    (68) exp -> ID OPEN_PAREN . explist CLOSE_PAREN
    (69) explist -> . exp
    (70) explist -> . explist SEPARATOR exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    explist                        shift and go to state 69
    exp                            shift and go to state 70
    lvalue                         shift and go to state 41

state 34

    (1) program -> PROGRAM ID SEMI_COLON declist block . SEMI_COLON

    SEMI_COLON      shift and go to state 71


state 35

    (4) declist -> declist dec .

    BEGIN           reduce using rule 4 (declist -> declist dec .)
    IF              reduce using rule 4 (declist -> declist dec .)
    WHILE           reduce using rule 4 (declist -> declist dec .)
    FOR             reduce using rule 4 (declist -> declist dec .)
    CASE            reduce using rule 4 (declist -> declist dec .)
    RETURN          reduce using rule 4 (declist -> declist dec .)
    PROCEDURE       reduce using rule 4 (declist -> declist dec .)
    FUNCTION        reduce using rule 4 (declist -> declist dec .)
    OPEN_PAREN      reduce using rule 4 (declist -> declist dec .)
    REALNUMBER      reduce using rule 4 (declist -> declist dec .)
    INTEGER         reduce using rule 4 (declist -> declist dec .)
    TRUE            reduce using rule 4 (declist -> declist dec .)
    FALSE           reduce using rule 4 (declist -> declist dec .)
    ID              reduce using rule 4 (declist -> declist dec .)
    INT             reduce using rule 4 (declist -> declist dec .)
    REAL            reduce using rule 4 (declist -> declist dec .)
    BOOL            reduce using rule 4 (declist -> declist dec .)


state 36

    (2) program -> PROGRAM ID SEMI_COLON block SEMI_COLON .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMI_COLON block SEMI_COLON .)


state 37

    (25) block -> BEGIN stmtlist . END
    (28) stmtlist -> stmtlist . SEMI_COLON stmt

    END             shift and go to state 72
    SEMI_COLON      shift and go to state 73


state 38

    (27) stmtlist -> stmt .

    END             reduce using rule 27 (stmtlist -> stmt .)
    SEMI_COLON      reduce using rule 27 (stmtlist -> stmt .)


state 39

    (32) stmt -> IF controlifexp . THEN block
    (33) stmt -> IF controlifexp . THEN block ELSE controlelse block

    THEN            shift and go to state 74


state 40

    (34) controlifexp -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    THEN            reduce using rule 34 (controlifexp -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 41

    (67) exp -> lvalue .

    SUM             reduce using rule 67 (exp -> lvalue .)
    SUB             reduce using rule 67 (exp -> lvalue .)
    MUL             reduce using rule 67 (exp -> lvalue .)
    DIV             reduce using rule 67 (exp -> lvalue .)
    AND             reduce using rule 67 (exp -> lvalue .)
    OR              reduce using rule 67 (exp -> lvalue .)
    NE              reduce using rule 67 (exp -> lvalue .)
    EQ              reduce using rule 67 (exp -> lvalue .)
    LT              reduce using rule 67 (exp -> lvalue .)
    GT              reduce using rule 67 (exp -> lvalue .)
    LE              reduce using rule 67 (exp -> lvalue .)
    GE              reduce using rule 67 (exp -> lvalue .)
    THEN            reduce using rule 67 (exp -> lvalue .)
    DO              reduce using rule 67 (exp -> lvalue .)
    INTEGER         reduce using rule 67 (exp -> lvalue .)
    SEMI_COLON      reduce using rule 67 (exp -> lvalue .)
    END             reduce using rule 67 (exp -> lvalue .)
    ELSE            reduce using rule 67 (exp -> lvalue .)
    CLOSE_PAREN     reduce using rule 67 (exp -> lvalue .)
    SEPARATOR       reduce using rule 67 (exp -> lvalue .)
    TO              reduce using rule 67 (exp -> lvalue .)
    DOWNTO          reduce using rule 67 (exp -> lvalue .)


state 42

    (36) stmt -> WHILE controlwhileexp . DO block

    DO              shift and go to state 75


state 43

    (37) controlwhileexp -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    DO              reduce using rule 37 (controlwhileexp -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 44

    (38) stmt -> FOR assignstmt . TO controlforupexp DO block
    (39) stmt -> FOR assignstmt . DOWNTO controlfordownexp DO block

    TO              shift and go to state 76
    DOWNTO          shift and go to state 77


state 45

    (30) assignstmt -> lvalue . ASSIGN exp

    ASSIGN          shift and go to state 68


state 46

    (29) lvalue -> ID .

    ASSIGN          reduce using rule 29 (lvalue -> ID .)


state 47

    (42) stmt -> CASE controlcaseexp . caseelement END
    (44) caseelement -> . case COLON caseelementcontrol block SEMI_COLON
    (45) caseelement -> . caseelement case COLON caseelementcontrol block SEMI_COLON
    (47) case -> . INTEGER

    INTEGER         shift and go to state 80

    caseelement                    shift and go to state 78
    case                           shift and go to state 79

state 48

    (43) controlcaseexp -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    INTEGER         reduce using rule 43 (controlcaseexp -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 49

    (48) stmt -> RETURN exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 48 (stmt -> RETURN exp .)
    END             reduce using rule 48 (stmt -> RETURN exp .)
    ELSE            reduce using rule 48 (stmt -> RETURN exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 50

    (50) exp -> exp SUM . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 81
    lvalue                         shift and go to state 41

state 51

    (51) exp -> exp SUB . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 82
    lvalue                         shift and go to state 41

state 52

    (52) exp -> exp MUL . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 83
    lvalue                         shift and go to state 41

state 53

    (53) exp -> exp DIV . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 84
    lvalue                         shift and go to state 41

state 54

    (54) exp -> exp AND . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 85
    lvalue                         shift and go to state 41

state 55

    (55) exp -> exp OR . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 86
    lvalue                         shift and go to state 41

state 56

    (56) exp -> exp NE . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 87
    lvalue                         shift and go to state 41

state 57

    (57) exp -> exp EQ . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 88
    lvalue                         shift and go to state 41

state 58

    (58) exp -> exp LT . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 89
    lvalue                         shift and go to state 41

state 59

    (59) exp -> exp GT . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 90
    lvalue                         shift and go to state 41

state 60

    (60) exp -> exp LE . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 91
    lvalue                         shift and go to state 41

state 61

    (61) exp -> exp GE . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 92
    lvalue                         shift and go to state 41

state 62

    (15) vardec -> type idlist . SEMI_COLON
    (14) idlist -> idlist . SEPARATOR iddec

    SEMI_COLON      shift and go to state 93
    SEPARATOR       shift and go to state 94


state 63

    (13) idlist -> iddec .

    SEMI_COLON      reduce using rule 13 (idlist -> iddec .)
    SEPARATOR       reduce using rule 13 (idlist -> iddec .)


state 64

    (11) iddec -> ID .
    (12) iddec -> ID . ASSIGN exp

    SEMI_COLON      reduce using rule 11 (iddec -> ID .)
    SEPARATOR       reduce using rule 11 (iddec -> ID .)
    ASSIGN          shift and go to state 95


state 65

    (16) procdec -> PROCEDURE ID . OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> PROCEDURE ID . OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON

    OPEN_PAREN      shift and go to state 96


state 66

    (62) exp -> OPEN_PAREN exp . CLOSE_PAREN
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    CLOSE_PAREN     shift and go to state 97
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 67

    (18) funcdec -> FUNCTION ID . OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID . OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON

    OPEN_PAREN      shift and go to state 98


state 68

    (30) assignstmt -> lvalue ASSIGN . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    lvalue                         shift and go to state 41
    exp                            shift and go to state 99

state 69

    (68) exp -> ID OPEN_PAREN explist . CLOSE_PAREN
    (70) explist -> explist . SEPARATOR exp

    CLOSE_PAREN     shift and go to state 100
    SEPARATOR       shift and go to state 101


state 70

    (69) explist -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    CLOSE_PAREN     reduce using rule 69 (explist -> exp .)
    SEPARATOR       reduce using rule 69 (explist -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 71

    (1) program -> PROGRAM ID SEMI_COLON declist block SEMI_COLON .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI_COLON declist block SEMI_COLON .)


state 72

    (25) block -> BEGIN stmtlist END .

    SEMI_COLON      reduce using rule 25 (block -> BEGIN stmtlist END .)
    ELSE            reduce using rule 25 (block -> BEGIN stmtlist END .)
    END             reduce using rule 25 (block -> BEGIN stmtlist END .)


state 73

    (28) stmtlist -> stmtlist SEMI_COLON . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    stmt                           shift and go to state 102
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 74

    (32) stmt -> IF controlifexp THEN . block
    (33) stmt -> IF controlifexp THEN . block ELSE controlelse block
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    block                          shift and go to state 103
    stmt                           shift and go to state 10
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 75

    (36) stmt -> WHILE controlwhileexp DO . block
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    block                          shift and go to state 104
    stmt                           shift and go to state 10
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 76

    (38) stmt -> FOR assignstmt TO . controlforupexp DO block
    (40) controlforupexp -> . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    controlforupexp                shift and go to state 105
    exp                            shift and go to state 106
    lvalue                         shift and go to state 41

state 77

    (39) stmt -> FOR assignstmt DOWNTO . controlfordownexp DO block
    (41) controlfordownexp -> . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    controlfordownexp              shift and go to state 107
    exp                            shift and go to state 108
    lvalue                         shift and go to state 41

state 78

    (42) stmt -> CASE controlcaseexp caseelement . END
    (45) caseelement -> caseelement . case COLON caseelementcontrol block SEMI_COLON
    (47) case -> . INTEGER

    END             shift and go to state 109
    INTEGER         shift and go to state 80

    case                           shift and go to state 110

state 79

    (44) caseelement -> case . COLON caseelementcontrol block SEMI_COLON

    COLON           shift and go to state 111


state 80

    (47) case -> INTEGER .

    COLON           reduce using rule 47 (case -> INTEGER .)


state 81

    (50) exp -> exp SUM exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SUM             reduce using rule 50 (exp -> exp SUM exp .)
    SUB             reduce using rule 50 (exp -> exp SUM exp .)
    AND             reduce using rule 50 (exp -> exp SUM exp .)
    OR              reduce using rule 50 (exp -> exp SUM exp .)
    NE              reduce using rule 50 (exp -> exp SUM exp .)
    EQ              reduce using rule 50 (exp -> exp SUM exp .)
    LT              reduce using rule 50 (exp -> exp SUM exp .)
    GT              reduce using rule 50 (exp -> exp SUM exp .)
    LE              reduce using rule 50 (exp -> exp SUM exp .)
    GE              reduce using rule 50 (exp -> exp SUM exp .)
    SEMI_COLON      reduce using rule 50 (exp -> exp SUM exp .)
    END             reduce using rule 50 (exp -> exp SUM exp .)
    THEN            reduce using rule 50 (exp -> exp SUM exp .)
    DO              reduce using rule 50 (exp -> exp SUM exp .)
    INTEGER         reduce using rule 50 (exp -> exp SUM exp .)
    ELSE            reduce using rule 50 (exp -> exp SUM exp .)
    CLOSE_PAREN     reduce using rule 50 (exp -> exp SUM exp .)
    SEPARATOR       reduce using rule 50 (exp -> exp SUM exp .)
    TO              reduce using rule 50 (exp -> exp SUM exp .)
    DOWNTO          reduce using rule 50 (exp -> exp SUM exp .)
    MUL             shift and go to state 52
    DIV             shift and go to state 53

  ! MUL             [ reduce using rule 50 (exp -> exp SUM exp .) ]
  ! DIV             [ reduce using rule 50 (exp -> exp SUM exp .) ]
  ! SUM             [ shift and go to state 50 ]
  ! SUB             [ shift and go to state 51 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! GE              [ shift and go to state 61 ]


state 82

    (51) exp -> exp SUB exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SUM             reduce using rule 51 (exp -> exp SUB exp .)
    SUB             reduce using rule 51 (exp -> exp SUB exp .)
    AND             reduce using rule 51 (exp -> exp SUB exp .)
    OR              reduce using rule 51 (exp -> exp SUB exp .)
    NE              reduce using rule 51 (exp -> exp SUB exp .)
    EQ              reduce using rule 51 (exp -> exp SUB exp .)
    LT              reduce using rule 51 (exp -> exp SUB exp .)
    GT              reduce using rule 51 (exp -> exp SUB exp .)
    LE              reduce using rule 51 (exp -> exp SUB exp .)
    GE              reduce using rule 51 (exp -> exp SUB exp .)
    SEMI_COLON      reduce using rule 51 (exp -> exp SUB exp .)
    END             reduce using rule 51 (exp -> exp SUB exp .)
    THEN            reduce using rule 51 (exp -> exp SUB exp .)
    DO              reduce using rule 51 (exp -> exp SUB exp .)
    INTEGER         reduce using rule 51 (exp -> exp SUB exp .)
    ELSE            reduce using rule 51 (exp -> exp SUB exp .)
    CLOSE_PAREN     reduce using rule 51 (exp -> exp SUB exp .)
    SEPARATOR       reduce using rule 51 (exp -> exp SUB exp .)
    TO              reduce using rule 51 (exp -> exp SUB exp .)
    DOWNTO          reduce using rule 51 (exp -> exp SUB exp .)
    MUL             shift and go to state 52
    DIV             shift and go to state 53

  ! MUL             [ reduce using rule 51 (exp -> exp SUB exp .) ]
  ! DIV             [ reduce using rule 51 (exp -> exp SUB exp .) ]
  ! SUM             [ shift and go to state 50 ]
  ! SUB             [ shift and go to state 51 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! GE              [ shift and go to state 61 ]


state 83

    (52) exp -> exp MUL exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SUM             reduce using rule 52 (exp -> exp MUL exp .)
    SUB             reduce using rule 52 (exp -> exp MUL exp .)
    MUL             reduce using rule 52 (exp -> exp MUL exp .)
    DIV             reduce using rule 52 (exp -> exp MUL exp .)
    AND             reduce using rule 52 (exp -> exp MUL exp .)
    OR              reduce using rule 52 (exp -> exp MUL exp .)
    NE              reduce using rule 52 (exp -> exp MUL exp .)
    EQ              reduce using rule 52 (exp -> exp MUL exp .)
    LT              reduce using rule 52 (exp -> exp MUL exp .)
    GT              reduce using rule 52 (exp -> exp MUL exp .)
    LE              reduce using rule 52 (exp -> exp MUL exp .)
    GE              reduce using rule 52 (exp -> exp MUL exp .)
    SEMI_COLON      reduce using rule 52 (exp -> exp MUL exp .)
    END             reduce using rule 52 (exp -> exp MUL exp .)
    THEN            reduce using rule 52 (exp -> exp MUL exp .)
    DO              reduce using rule 52 (exp -> exp MUL exp .)
    INTEGER         reduce using rule 52 (exp -> exp MUL exp .)
    ELSE            reduce using rule 52 (exp -> exp MUL exp .)
    CLOSE_PAREN     reduce using rule 52 (exp -> exp MUL exp .)
    SEPARATOR       reduce using rule 52 (exp -> exp MUL exp .)
    TO              reduce using rule 52 (exp -> exp MUL exp .)
    DOWNTO          reduce using rule 52 (exp -> exp MUL exp .)

  ! SUM             [ shift and go to state 50 ]
  ! SUB             [ shift and go to state 51 ]
  ! MUL             [ shift and go to state 52 ]
  ! DIV             [ shift and go to state 53 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! GE              [ shift and go to state 61 ]


state 84

    (53) exp -> exp DIV exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SUM             reduce using rule 53 (exp -> exp DIV exp .)
    SUB             reduce using rule 53 (exp -> exp DIV exp .)
    MUL             reduce using rule 53 (exp -> exp DIV exp .)
    DIV             reduce using rule 53 (exp -> exp DIV exp .)
    AND             reduce using rule 53 (exp -> exp DIV exp .)
    OR              reduce using rule 53 (exp -> exp DIV exp .)
    NE              reduce using rule 53 (exp -> exp DIV exp .)
    EQ              reduce using rule 53 (exp -> exp DIV exp .)
    LT              reduce using rule 53 (exp -> exp DIV exp .)
    GT              reduce using rule 53 (exp -> exp DIV exp .)
    LE              reduce using rule 53 (exp -> exp DIV exp .)
    GE              reduce using rule 53 (exp -> exp DIV exp .)
    SEMI_COLON      reduce using rule 53 (exp -> exp DIV exp .)
    END             reduce using rule 53 (exp -> exp DIV exp .)
    THEN            reduce using rule 53 (exp -> exp DIV exp .)
    DO              reduce using rule 53 (exp -> exp DIV exp .)
    INTEGER         reduce using rule 53 (exp -> exp DIV exp .)
    ELSE            reduce using rule 53 (exp -> exp DIV exp .)
    CLOSE_PAREN     reduce using rule 53 (exp -> exp DIV exp .)
    SEPARATOR       reduce using rule 53 (exp -> exp DIV exp .)
    TO              reduce using rule 53 (exp -> exp DIV exp .)
    DOWNTO          reduce using rule 53 (exp -> exp DIV exp .)

  ! SUM             [ shift and go to state 50 ]
  ! SUB             [ shift and go to state 51 ]
  ! MUL             [ shift and go to state 52 ]
  ! DIV             [ shift and go to state 53 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! GE              [ shift and go to state 61 ]


state 85

    (54) exp -> exp AND exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 54 (exp -> exp AND exp .)
    OR              reduce using rule 54 (exp -> exp AND exp .)
    SEMI_COLON      reduce using rule 54 (exp -> exp AND exp .)
    END             reduce using rule 54 (exp -> exp AND exp .)
    THEN            reduce using rule 54 (exp -> exp AND exp .)
    DO              reduce using rule 54 (exp -> exp AND exp .)
    INTEGER         reduce using rule 54 (exp -> exp AND exp .)
    ELSE            reduce using rule 54 (exp -> exp AND exp .)
    CLOSE_PAREN     reduce using rule 54 (exp -> exp AND exp .)
    SEPARATOR       reduce using rule 54 (exp -> exp AND exp .)
    TO              reduce using rule 54 (exp -> exp AND exp .)
    DOWNTO          reduce using rule 54 (exp -> exp AND exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61

  ! SUM             [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! SUB             [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! MUL             [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! DIV             [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! EQ              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 54 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]


state 86

    (55) exp -> exp OR exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    OR              reduce using rule 55 (exp -> exp OR exp .)
    SEMI_COLON      reduce using rule 55 (exp -> exp OR exp .)
    END             reduce using rule 55 (exp -> exp OR exp .)
    THEN            reduce using rule 55 (exp -> exp OR exp .)
    DO              reduce using rule 55 (exp -> exp OR exp .)
    INTEGER         reduce using rule 55 (exp -> exp OR exp .)
    ELSE            reduce using rule 55 (exp -> exp OR exp .)
    CLOSE_PAREN     reduce using rule 55 (exp -> exp OR exp .)
    SEPARATOR       reduce using rule 55 (exp -> exp OR exp .)
    TO              reduce using rule 55 (exp -> exp OR exp .)
    DOWNTO          reduce using rule 55 (exp -> exp OR exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61

  ! SUM             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! SUB             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! MUL             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! DIV             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! EQ              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 55 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 55 ]


state 87

    (56) exp -> exp NE exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 56 (exp -> exp NE exp .)
    OR              reduce using rule 56 (exp -> exp NE exp .)
    NE              reduce using rule 56 (exp -> exp NE exp .)
    LT              reduce using rule 56 (exp -> exp NE exp .)
    GT              reduce using rule 56 (exp -> exp NE exp .)
    GE              reduce using rule 56 (exp -> exp NE exp .)
    SEMI_COLON      reduce using rule 56 (exp -> exp NE exp .)
    END             reduce using rule 56 (exp -> exp NE exp .)
    THEN            reduce using rule 56 (exp -> exp NE exp .)
    DO              reduce using rule 56 (exp -> exp NE exp .)
    INTEGER         reduce using rule 56 (exp -> exp NE exp .)
    ELSE            reduce using rule 56 (exp -> exp NE exp .)
    CLOSE_PAREN     reduce using rule 56 (exp -> exp NE exp .)
    SEPARATOR       reduce using rule 56 (exp -> exp NE exp .)
    TO              reduce using rule 56 (exp -> exp NE exp .)
    DOWNTO          reduce using rule 56 (exp -> exp NE exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    EQ              shift and go to state 57
    LE              shift and go to state 60

  ! SUM             [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! SUB             [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! MUL             [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! DIV             [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! EQ              [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! LE              [ reduce using rule 56 (exp -> exp NE exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! GE              [ shift and go to state 61 ]


state 88

    (57) exp -> exp EQ exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 57 (exp -> exp EQ exp .)
    OR              reduce using rule 57 (exp -> exp EQ exp .)
    NE              reduce using rule 57 (exp -> exp EQ exp .)
    EQ              reduce using rule 57 (exp -> exp EQ exp .)
    LT              reduce using rule 57 (exp -> exp EQ exp .)
    GT              reduce using rule 57 (exp -> exp EQ exp .)
    GE              reduce using rule 57 (exp -> exp EQ exp .)
    SEMI_COLON      reduce using rule 57 (exp -> exp EQ exp .)
    END             reduce using rule 57 (exp -> exp EQ exp .)
    THEN            reduce using rule 57 (exp -> exp EQ exp .)
    DO              reduce using rule 57 (exp -> exp EQ exp .)
    INTEGER         reduce using rule 57 (exp -> exp EQ exp .)
    ELSE            reduce using rule 57 (exp -> exp EQ exp .)
    CLOSE_PAREN     reduce using rule 57 (exp -> exp EQ exp .)
    SEPARATOR       reduce using rule 57 (exp -> exp EQ exp .)
    TO              reduce using rule 57 (exp -> exp EQ exp .)
    DOWNTO          reduce using rule 57 (exp -> exp EQ exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    LE              shift and go to state 60

  ! SUM             [ reduce using rule 57 (exp -> exp EQ exp .) ]
  ! SUB             [ reduce using rule 57 (exp -> exp EQ exp .) ]
  ! MUL             [ reduce using rule 57 (exp -> exp EQ exp .) ]
  ! DIV             [ reduce using rule 57 (exp -> exp EQ exp .) ]
  ! LE              [ reduce using rule 57 (exp -> exp EQ exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! GE              [ shift and go to state 61 ]


state 89

    (58) exp -> exp LT exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 58 (exp -> exp LT exp .)
    OR              reduce using rule 58 (exp -> exp LT exp .)
    LT              reduce using rule 58 (exp -> exp LT exp .)
    SEMI_COLON      reduce using rule 58 (exp -> exp LT exp .)
    END             reduce using rule 58 (exp -> exp LT exp .)
    THEN            reduce using rule 58 (exp -> exp LT exp .)
    DO              reduce using rule 58 (exp -> exp LT exp .)
    INTEGER         reduce using rule 58 (exp -> exp LT exp .)
    ELSE            reduce using rule 58 (exp -> exp LT exp .)
    CLOSE_PAREN     reduce using rule 58 (exp -> exp LT exp .)
    SEPARATOR       reduce using rule 58 (exp -> exp LT exp .)
    TO              reduce using rule 58 (exp -> exp LT exp .)
    DOWNTO          reduce using rule 58 (exp -> exp LT exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    NE              shift and go to state 56
    EQ              shift and go to state 57
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61

  ! SUM             [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! SUB             [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! MUL             [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! DIV             [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! NE              [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! EQ              [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! LE              [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! GE              [ reduce using rule 58 (exp -> exp LT exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]


state 90

    (59) exp -> exp GT exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 59 (exp -> exp GT exp .)
    OR              reduce using rule 59 (exp -> exp GT exp .)
    LT              reduce using rule 59 (exp -> exp GT exp .)
    GT              reduce using rule 59 (exp -> exp GT exp .)
    SEMI_COLON      reduce using rule 59 (exp -> exp GT exp .)
    END             reduce using rule 59 (exp -> exp GT exp .)
    THEN            reduce using rule 59 (exp -> exp GT exp .)
    DO              reduce using rule 59 (exp -> exp GT exp .)
    INTEGER         reduce using rule 59 (exp -> exp GT exp .)
    ELSE            reduce using rule 59 (exp -> exp GT exp .)
    CLOSE_PAREN     reduce using rule 59 (exp -> exp GT exp .)
    SEPARATOR       reduce using rule 59 (exp -> exp GT exp .)
    TO              reduce using rule 59 (exp -> exp GT exp .)
    DOWNTO          reduce using rule 59 (exp -> exp GT exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LE              shift and go to state 60
    GE              shift and go to state 61

  ! SUM             [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! SUB             [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! MUL             [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! DIV             [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! NE              [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! EQ              [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! LE              [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! GE              [ reduce using rule 59 (exp -> exp GT exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]


state 91

    (60) exp -> exp LE exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 60 (exp -> exp LE exp .)
    OR              reduce using rule 60 (exp -> exp LE exp .)
    NE              reduce using rule 60 (exp -> exp LE exp .)
    EQ              reduce using rule 60 (exp -> exp LE exp .)
    LT              reduce using rule 60 (exp -> exp LE exp .)
    GT              reduce using rule 60 (exp -> exp LE exp .)
    LE              reduce using rule 60 (exp -> exp LE exp .)
    GE              reduce using rule 60 (exp -> exp LE exp .)
    SEMI_COLON      reduce using rule 60 (exp -> exp LE exp .)
    END             reduce using rule 60 (exp -> exp LE exp .)
    THEN            reduce using rule 60 (exp -> exp LE exp .)
    DO              reduce using rule 60 (exp -> exp LE exp .)
    INTEGER         reduce using rule 60 (exp -> exp LE exp .)
    ELSE            reduce using rule 60 (exp -> exp LE exp .)
    CLOSE_PAREN     reduce using rule 60 (exp -> exp LE exp .)
    SEPARATOR       reduce using rule 60 (exp -> exp LE exp .)
    TO              reduce using rule 60 (exp -> exp LE exp .)
    DOWNTO          reduce using rule 60 (exp -> exp LE exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53

  ! SUM             [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! SUB             [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! MUL             [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! DIV             [ reduce using rule 60 (exp -> exp LE exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! NE              [ shift and go to state 56 ]
  ! EQ              [ shift and go to state 57 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! LE              [ shift and go to state 60 ]
  ! GE              [ shift and go to state 61 ]


state 92

    (61) exp -> exp GE exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    AND             reduce using rule 61 (exp -> exp GE exp .)
    OR              reduce using rule 61 (exp -> exp GE exp .)
    LT              reduce using rule 61 (exp -> exp GE exp .)
    GT              reduce using rule 61 (exp -> exp GE exp .)
    GE              reduce using rule 61 (exp -> exp GE exp .)
    SEMI_COLON      reduce using rule 61 (exp -> exp GE exp .)
    END             reduce using rule 61 (exp -> exp GE exp .)
    THEN            reduce using rule 61 (exp -> exp GE exp .)
    DO              reduce using rule 61 (exp -> exp GE exp .)
    INTEGER         reduce using rule 61 (exp -> exp GE exp .)
    ELSE            reduce using rule 61 (exp -> exp GE exp .)
    CLOSE_PAREN     reduce using rule 61 (exp -> exp GE exp .)
    SEPARATOR       reduce using rule 61 (exp -> exp GE exp .)
    TO              reduce using rule 61 (exp -> exp GE exp .)
    DOWNTO          reduce using rule 61 (exp -> exp GE exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LE              shift and go to state 60

  ! SUM             [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! SUB             [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! MUL             [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! DIV             [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! NE              [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! EQ              [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! LE              [ reduce using rule 61 (exp -> exp GE exp .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 55 ]
  ! LT              [ shift and go to state 58 ]
  ! GT              [ shift and go to state 59 ]
  ! GE              [ shift and go to state 61 ]


state 93

    (15) vardec -> type idlist SEMI_COLON .

    BEGIN           reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    IF              reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    WHILE           reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    FOR             reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    CASE            reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    RETURN          reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    PROCEDURE       reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    FUNCTION        reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    OPEN_PAREN      reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    REALNUMBER      reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    INTEGER         reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    TRUE            reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    FALSE           reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    ID              reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    INT             reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    REAL            reduce using rule 15 (vardec -> type idlist SEMI_COLON .)
    BOOL            reduce using rule 15 (vardec -> type idlist SEMI_COLON .)


state 94

    (14) idlist -> idlist SEPARATOR . iddec
    (11) iddec -> . ID
    (12) iddec -> . ID ASSIGN exp

    ID              shift and go to state 64

    iddec                          shift and go to state 112

state 95

    (12) iddec -> ID ASSIGN . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 113
    lvalue                         shift and go to state 41

state 96

    (16) procdec -> PROCEDURE ID OPEN_PAREN . paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> PROCEDURE ID OPEN_PAREN . paramdecs CLOSE_PAREN block SEMI_COLON
    (20) paramdecs -> . paramdec
    (21) paramdecs -> . paramdecs SEMI_COLON paramdec
    (22) paramdec -> . type paramlist
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL

    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    paramdecs                      shift and go to state 114
    paramdec                       shift and go to state 115
    type                           shift and go to state 116

state 97

    (62) exp -> OPEN_PAREN exp CLOSE_PAREN .

    SUM             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SUB             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    MUL             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DIV             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    AND             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    OR              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    NE              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    EQ              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    LT              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    GT              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    LE              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    GE              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    END             reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    THEN            reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DO              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    INTEGER         reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    ELSE            reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SEPARATOR       reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    TO              reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DOWNTO          reduce using rule 62 (exp -> OPEN_PAREN exp CLOSE_PAREN .)


state 98

    (18) funcdec -> FUNCTION ID OPEN_PAREN . paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID OPEN_PAREN . paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (20) paramdecs -> . paramdec
    (21) paramdecs -> . paramdecs SEMI_COLON paramdec
    (22) paramdec -> . type paramlist
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL

    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    paramdecs                      shift and go to state 117
    type                           shift and go to state 116
    paramdec                       shift and go to state 115

state 99

    (30) assignstmt -> lvalue ASSIGN exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 30 (assignstmt -> lvalue ASSIGN exp .)
    END             reduce using rule 30 (assignstmt -> lvalue ASSIGN exp .)
    TO              reduce using rule 30 (assignstmt -> lvalue ASSIGN exp .)
    DOWNTO          reduce using rule 30 (assignstmt -> lvalue ASSIGN exp .)
    ELSE            reduce using rule 30 (assignstmt -> lvalue ASSIGN exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 100

    (68) exp -> ID OPEN_PAREN explist CLOSE_PAREN .

    SUM             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SUB             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    MUL             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DIV             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    AND             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    OR              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    NE              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    EQ              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    LT              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    GT              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    LE              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    GE              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    END             reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    THEN            reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DO              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    INTEGER         reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    ELSE            reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SEPARATOR       reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    TO              reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DOWNTO          reduce using rule 68 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)


state 101

    (70) explist -> explist SEPARATOR . exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    exp                            shift and go to state 118
    lvalue                         shift and go to state 41

state 102

    (28) stmtlist -> stmtlist SEMI_COLON stmt .

    END             reduce using rule 28 (stmtlist -> stmtlist SEMI_COLON stmt .)
    SEMI_COLON      reduce using rule 28 (stmtlist -> stmtlist SEMI_COLON stmt .)


state 103

    (32) stmt -> IF controlifexp THEN block .
    (33) stmt -> IF controlifexp THEN block . ELSE controlelse block

    SEMI_COLON      reduce using rule 32 (stmt -> IF controlifexp THEN block .)
    END             reduce using rule 32 (stmt -> IF controlifexp THEN block .)
    ELSE            shift and go to state 119

  ! ELSE            [ reduce using rule 32 (stmt -> IF controlifexp THEN block .) ]


state 104

    (36) stmt -> WHILE controlwhileexp DO block .

    SEMI_COLON      reduce using rule 36 (stmt -> WHILE controlwhileexp DO block .)
    END             reduce using rule 36 (stmt -> WHILE controlwhileexp DO block .)
    ELSE            reduce using rule 36 (stmt -> WHILE controlwhileexp DO block .)


state 105

    (38) stmt -> FOR assignstmt TO controlforupexp . DO block

    DO              shift and go to state 120


state 106

    (40) controlforupexp -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    DO              reduce using rule 40 (controlforupexp -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 107

    (39) stmt -> FOR assignstmt DOWNTO controlfordownexp . DO block

    DO              shift and go to state 121


state 108

    (41) controlfordownexp -> exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    DO              reduce using rule 41 (controlfordownexp -> exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 109

    (42) stmt -> CASE controlcaseexp caseelement END .

    SEMI_COLON      reduce using rule 42 (stmt -> CASE controlcaseexp caseelement END .)
    END             reduce using rule 42 (stmt -> CASE controlcaseexp caseelement END .)
    ELSE            reduce using rule 42 (stmt -> CASE controlcaseexp caseelement END .)


state 110

    (45) caseelement -> caseelement case . COLON caseelementcontrol block SEMI_COLON

    COLON           shift and go to state 122


state 111

    (44) caseelement -> case COLON . caseelementcontrol block SEMI_COLON
    (46) caseelementcontrol -> .

    BEGIN           reduce using rule 46 (caseelementcontrol -> .)
    IF              reduce using rule 46 (caseelementcontrol -> .)
    WHILE           reduce using rule 46 (caseelementcontrol -> .)
    FOR             reduce using rule 46 (caseelementcontrol -> .)
    CASE            reduce using rule 46 (caseelementcontrol -> .)
    RETURN          reduce using rule 46 (caseelementcontrol -> .)
    OPEN_PAREN      reduce using rule 46 (caseelementcontrol -> .)
    REALNUMBER      reduce using rule 46 (caseelementcontrol -> .)
    INTEGER         reduce using rule 46 (caseelementcontrol -> .)
    TRUE            reduce using rule 46 (caseelementcontrol -> .)
    FALSE           reduce using rule 46 (caseelementcontrol -> .)
    ID              reduce using rule 46 (caseelementcontrol -> .)

    caseelementcontrol             shift and go to state 123

state 112

    (14) idlist -> idlist SEPARATOR iddec .

    SEMI_COLON      reduce using rule 14 (idlist -> idlist SEPARATOR iddec .)
    SEPARATOR       reduce using rule 14 (idlist -> idlist SEPARATOR iddec .)


state 113

    (12) iddec -> ID ASSIGN exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 12 (iddec -> ID ASSIGN exp .)
    SEPARATOR       reduce using rule 12 (iddec -> ID ASSIGN exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 114

    (16) procdec -> PROCEDURE ID OPEN_PAREN paramdecs . CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> PROCEDURE ID OPEN_PAREN paramdecs . CLOSE_PAREN block SEMI_COLON
    (21) paramdecs -> paramdecs . SEMI_COLON paramdec

    CLOSE_PAREN     shift and go to state 124
    SEMI_COLON      shift and go to state 125


state 115

    (20) paramdecs -> paramdec .

    CLOSE_PAREN     reduce using rule 20 (paramdecs -> paramdec .)
    SEMI_COLON      reduce using rule 20 (paramdecs -> paramdec .)


state 116

    (22) paramdec -> type . paramlist
    (23) paramlist -> . ID
    (24) paramlist -> . paramlist SEPARATOR ID

    ID              shift and go to state 127

    paramlist                      shift and go to state 126

state 117

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs . CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs . CLOSE_PAREN COLON type block SEMI_COLON
    (21) paramdecs -> paramdecs . SEMI_COLON paramdec

    CLOSE_PAREN     shift and go to state 128
    SEMI_COLON      shift and go to state 125


state 118

    (70) explist -> explist SEPARATOR exp .
    (50) exp -> exp . SUM exp
    (51) exp -> exp . SUB exp
    (52) exp -> exp . MUL exp
    (53) exp -> exp . DIV exp
    (54) exp -> exp . AND exp
    (55) exp -> exp . OR exp
    (56) exp -> exp . NE exp
    (57) exp -> exp . EQ exp
    (58) exp -> exp . LT exp
    (59) exp -> exp . GT exp
    (60) exp -> exp . LE exp
    (61) exp -> exp . GE exp

    CLOSE_PAREN     reduce using rule 70 (explist -> explist SEPARATOR exp .)
    SEPARATOR       reduce using rule 70 (explist -> explist SEPARATOR exp .)
    SUM             shift and go to state 50
    SUB             shift and go to state 51
    MUL             shift and go to state 52
    DIV             shift and go to state 53
    AND             shift and go to state 54
    OR              shift and go to state 55
    NE              shift and go to state 56
    EQ              shift and go to state 57
    LT              shift and go to state 58
    GT              shift and go to state 59
    LE              shift and go to state 60
    GE              shift and go to state 61


state 119

    (33) stmt -> IF controlifexp THEN block ELSE . controlelse block
    (35) controlelse -> .

    BEGIN           reduce using rule 35 (controlelse -> .)
    IF              reduce using rule 35 (controlelse -> .)
    WHILE           reduce using rule 35 (controlelse -> .)
    FOR             reduce using rule 35 (controlelse -> .)
    CASE            reduce using rule 35 (controlelse -> .)
    RETURN          reduce using rule 35 (controlelse -> .)
    OPEN_PAREN      reduce using rule 35 (controlelse -> .)
    REALNUMBER      reduce using rule 35 (controlelse -> .)
    INTEGER         reduce using rule 35 (controlelse -> .)
    TRUE            reduce using rule 35 (controlelse -> .)
    FALSE           reduce using rule 35 (controlelse -> .)
    ID              reduce using rule 35 (controlelse -> .)

    controlelse                    shift and go to state 129

state 120

    (38) stmt -> FOR assignstmt TO controlforupexp DO . block
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    assignstmt                     shift and go to state 14
    block                          shift and go to state 130
    stmt                           shift and go to state 10
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 121

    (39) stmt -> FOR assignstmt DOWNTO controlfordownexp DO . block
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    assignstmt                     shift and go to state 14
    block                          shift and go to state 131
    stmt                           shift and go to state 10
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 122

    (45) caseelement -> caseelement case COLON . caseelementcontrol block SEMI_COLON
    (46) caseelementcontrol -> .

    BEGIN           reduce using rule 46 (caseelementcontrol -> .)
    IF              reduce using rule 46 (caseelementcontrol -> .)
    WHILE           reduce using rule 46 (caseelementcontrol -> .)
    FOR             reduce using rule 46 (caseelementcontrol -> .)
    CASE            reduce using rule 46 (caseelementcontrol -> .)
    RETURN          reduce using rule 46 (caseelementcontrol -> .)
    OPEN_PAREN      reduce using rule 46 (caseelementcontrol -> .)
    REALNUMBER      reduce using rule 46 (caseelementcontrol -> .)
    INTEGER         reduce using rule 46 (caseelementcontrol -> .)
    TRUE            reduce using rule 46 (caseelementcontrol -> .)
    FALSE           reduce using rule 46 (caseelementcontrol -> .)
    ID              reduce using rule 46 (caseelementcontrol -> .)

    caseelementcontrol             shift and go to state 132

state 123

    (44) caseelement -> case COLON caseelementcontrol . block SEMI_COLON
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    block                          shift and go to state 133
    stmt                           shift and go to state 10
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 124

    (16) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN . declist block SEMI_COLON
    (17) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN . block SEMI_COLON
    (3) declist -> . dec
    (4) declist -> . declist dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    declist                        shift and go to state 134
    block                          shift and go to state 135
    dec                            shift and go to state 8
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    type                           shift and go to state 21
    lvalue                         shift and go to state 25

state 125

    (21) paramdecs -> paramdecs SEMI_COLON . paramdec
    (22) paramdec -> . type paramlist
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL

    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    paramdec                       shift and go to state 136
    type                           shift and go to state 116

state 126

    (22) paramdec -> type paramlist .
    (24) paramlist -> paramlist . SEPARATOR ID

    CLOSE_PAREN     reduce using rule 22 (paramdec -> type paramlist .)
    SEMI_COLON      reduce using rule 22 (paramdec -> type paramlist .)
    SEPARATOR       shift and go to state 137


state 127

    (23) paramlist -> ID .

    SEPARATOR       reduce using rule 23 (paramlist -> ID .)
    CLOSE_PAREN     reduce using rule 23 (paramlist -> ID .)
    SEMI_COLON      reduce using rule 23 (paramlist -> ID .)


state 128

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN . COLON type declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN . COLON type block SEMI_COLON

    COLON           shift and go to state 138


state 129

    (33) stmt -> IF controlifexp THEN block ELSE controlelse . block
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    block                          shift and go to state 139
    stmt                           shift and go to state 10
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 130

    (38) stmt -> FOR assignstmt TO controlforupexp DO block .

    SEMI_COLON      reduce using rule 38 (stmt -> FOR assignstmt TO controlforupexp DO block .)
    END             reduce using rule 38 (stmt -> FOR assignstmt TO controlforupexp DO block .)
    ELSE            reduce using rule 38 (stmt -> FOR assignstmt TO controlforupexp DO block .)


state 131

    (39) stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .

    SEMI_COLON      reduce using rule 39 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)
    END             reduce using rule 39 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)
    ELSE            reduce using rule 39 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)


state 132

    (45) caseelement -> caseelement case COLON caseelementcontrol . block SEMI_COLON
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5

    block                          shift and go to state 140
    stmt                           shift and go to state 10
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 133

    (44) caseelement -> case COLON caseelementcontrol block . SEMI_COLON

    SEMI_COLON      shift and go to state 141


state 134

    (16) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist . block SEMI_COLON
    (4) declist -> declist . dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    block                          shift and go to state 142
    dec                            shift and go to state 35
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    type                           shift and go to state 21
    lvalue                         shift and go to state 25

state 135

    (17) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block . SEMI_COLON

    SEMI_COLON      shift and go to state 143


state 136

    (21) paramdecs -> paramdecs SEMI_COLON paramdec .

    CLOSE_PAREN     reduce using rule 21 (paramdecs -> paramdecs SEMI_COLON paramdec .)
    SEMI_COLON      reduce using rule 21 (paramdecs -> paramdecs SEMI_COLON paramdec .)


state 137

    (24) paramlist -> paramlist SEPARATOR . ID

    ID              shift and go to state 144


state 138

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON . type declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON . type block SEMI_COLON
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL

    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    type                           shift and go to state 145

state 139

    (33) stmt -> IF controlifexp THEN block ELSE controlelse block .

    SEMI_COLON      reduce using rule 33 (stmt -> IF controlifexp THEN block ELSE controlelse block .)
    END             reduce using rule 33 (stmt -> IF controlifexp THEN block ELSE controlelse block .)
    ELSE            reduce using rule 33 (stmt -> IF controlifexp THEN block ELSE controlelse block .)


state 140

    (45) caseelement -> caseelement case COLON caseelementcontrol block . SEMI_COLON

    SEMI_COLON      shift and go to state 146


state 141

    (44) caseelement -> case COLON caseelementcontrol block SEMI_COLON .

    END             reduce using rule 44 (caseelement -> case COLON caseelementcontrol block SEMI_COLON .)
    INTEGER         reduce using rule 44 (caseelement -> case COLON caseelementcontrol block SEMI_COLON .)


state 142

    (16) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block . SEMI_COLON

    SEMI_COLON      shift and go to state 147


state 143

    (17) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .

    BEGIN           reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    IF              reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    WHILE           reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    FOR             reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    CASE            reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    RETURN          reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    PROCEDURE       reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    FUNCTION        reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    REALNUMBER      reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    INTEGER         reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    TRUE            reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    FALSE           reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    ID              reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    INT             reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    REAL            reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)
    BOOL            reduce using rule 17 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON .)


state 144

    (24) paramlist -> paramlist SEPARATOR ID .

    SEPARATOR       reduce using rule 24 (paramlist -> paramlist SEPARATOR ID .)
    CLOSE_PAREN     reduce using rule 24 (paramlist -> paramlist SEPARATOR ID .)
    SEMI_COLON      reduce using rule 24 (paramlist -> paramlist SEPARATOR ID .)


state 145

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type . declist block SEMI_COLON
    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type . block SEMI_COLON
    (3) declist -> . dec
    (4) declist -> . declist dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    type                           shift and go to state 21
    declist                        shift and go to state 148
    block                          shift and go to state 149
    dec                            shift and go to state 8
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 146

    (45) caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .

    END             reduce using rule 45 (caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .)
    INTEGER         reduce using rule 45 (caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .)


state 147

    (16) procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .

    BEGIN           reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    IF              reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    WHILE           reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    FOR             reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    CASE            reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    RETURN          reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    PROCEDURE       reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    FUNCTION        reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    REALNUMBER      reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    INTEGER         reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    TRUE            reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    FALSE           reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    ID              reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    INT             reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    REAL            reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)
    BOOL            reduce using rule 16 (procdec -> PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON .)


state 148

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist . block SEMI_COLON
    (4) declist -> declist . dec
    (25) block -> . BEGIN stmtlist END
    (26) block -> . stmt
    (5) dec -> . vardec
    (6) dec -> . procdec
    (7) dec -> . funcdec
    (31) stmt -> . assignstmt
    (32) stmt -> . IF controlifexp THEN block
    (33) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (36) stmt -> . WHILE controlwhileexp DO block
    (38) stmt -> . FOR assignstmt TO controlforupexp DO block
    (39) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (42) stmt -> . CASE controlcaseexp caseelement END
    (48) stmt -> . RETURN exp
    (49) stmt -> . exp
    (15) vardec -> . type idlist SEMI_COLON
    (16) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN declist block SEMI_COLON
    (17) procdec -> . PROCEDURE ID OPEN_PAREN paramdecs CLOSE_PAREN block SEMI_COLON
    (18) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON
    (19) funcdec -> . FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON
    (30) assignstmt -> . lvalue ASSIGN exp
    (50) exp -> . exp SUM exp
    (51) exp -> . exp SUB exp
    (52) exp -> . exp MUL exp
    (53) exp -> . exp DIV exp
    (54) exp -> . exp AND exp
    (55) exp -> . exp OR exp
    (56) exp -> . exp NE exp
    (57) exp -> . exp EQ exp
    (58) exp -> . exp LT exp
    (59) exp -> . exp GT exp
    (60) exp -> . exp LE exp
    (61) exp -> . exp GE exp
    (62) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (63) exp -> . REALNUMBER
    (64) exp -> . INTEGER
    (65) exp -> . TRUE
    (66) exp -> . FALSE
    (67) exp -> . lvalue
    (68) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (8) type -> . INT
    (9) type -> . REAL
    (10) type -> . BOOL
    (29) lvalue -> . ID

    BEGIN           shift and go to state 9
    IF              shift and go to state 15
    WHILE           shift and go to state 16
    FOR             shift and go to state 17
    CASE            shift and go to state 18
    RETURN          shift and go to state 19
    PROCEDURE       shift and go to state 22
    FUNCTION        shift and go to state 24
    OPEN_PAREN      shift and go to state 23
    REALNUMBER      shift and go to state 26
    INTEGER         shift and go to state 27
    TRUE            shift and go to state 28
    FALSE           shift and go to state 29
    ID              shift and go to state 5
    INT             shift and go to state 30
    REAL            shift and go to state 31
    BOOL            shift and go to state 32

    type                           shift and go to state 21
    block                          shift and go to state 150
    dec                            shift and go to state 35
    stmt                           shift and go to state 10
    vardec                         shift and go to state 11
    procdec                        shift and go to state 12
    funcdec                        shift and go to state 13
    assignstmt                     shift and go to state 14
    exp                            shift and go to state 20
    lvalue                         shift and go to state 25

state 149

    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block . SEMI_COLON

    SEMI_COLON      shift and go to state 151


state 150

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block . SEMI_COLON

    SEMI_COLON      shift and go to state 152


state 151

    (19) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .

    BEGIN           reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    IF              reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    WHILE           reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    FOR             reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    CASE            reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    RETURN          reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    PROCEDURE       reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    FUNCTION        reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    REALNUMBER      reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    INTEGER         reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    TRUE            reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    FALSE           reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    ID              reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    INT             reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    REAL            reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)
    BOOL            reduce using rule 19 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type block SEMI_COLON .)


state 152

    (18) funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .

    BEGIN           reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    IF              reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    WHILE           reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    FOR             reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    CASE            reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    RETURN          reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    PROCEDURE       reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    FUNCTION        reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    REALNUMBER      reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    INTEGER         reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    TRUE            reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    FALSE           reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    ID              reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    INT             reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    REAL            reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)
    BOOL            reduce using rule 18 (funcdec -> FUNCTION ID OPEN_PAREN paramdecs CLOSE_PAREN COLON type declist block SEMI_COLON .)

