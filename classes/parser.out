Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMI_COLON declistlast block SEMI_COLON
Rule 2     declistlast -> declist
Rule 3     declistlast -> <empty>
Rule 4     declist -> dec
Rule 5     declist -> declist dec
Rule 6     dec -> vardec
Rule 7     dec -> procdec
Rule 8     dec -> funcdec
Rule 9     type -> INT
Rule 10    type -> REAL
Rule 11    type -> BOOL
Rule 12    iddec -> ID
Rule 13    iddec -> ID ASSIGN exp
Rule 14    idlist -> iddec
Rule 15    idlist -> idlist SEPARATOR iddec
Rule 16    vardec -> type idlist SEMI_COLON
Rule 17    paramdecslast -> paramdecs
Rule 18    paramdecslast -> <empty>
Rule 19    procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
Rule 20    funcname -> FUNCTION ID
Rule 21    funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
Rule 22    paramdecs -> paramdec
Rule 23    paramdecs -> paramdecs SEMI_COLON paramdec
Rule 24    paramdec -> type paramlist
Rule 25    paramlist -> ID
Rule 26    paramlist -> paramlist SEPARATOR ID
Rule 27    block -> BEGIN stmtlist END
Rule 28    block -> stmt
Rule 29    stmtlist -> stmt
Rule 30    stmtlist -> stmtlist SEMI_COLON stmt
Rule 31    lvalue -> ID
Rule 32    assignstmt -> lvalue ASSIGN exp
Rule 33    stmt -> assignstmt
Rule 34    stmt -> IF controlifexp THEN block
Rule 35    stmt -> IF controlifexp THEN block ELSE controlelse block
Rule 36    controlifexp -> exp
Rule 37    controlelse -> <empty>
Rule 38    stmt -> PRINT OPEN_PAREN ID CLOSE_PAREN
Rule 39    stmt -> WHILE controlwhileexp DO block
Rule 40    controlwhileexp -> exp
Rule 41    stmt -> FOR assignstmt TO controlforupexp DO block
Rule 42    stmt -> FOR assignstmt DOWNTO controlfordownexp DO block
Rule 43    controlforupexp -> exp
Rule 44    controlfordownexp -> exp
Rule 45    stmt -> CASE controlcaseexp caseelement END
Rule 46    controlcaseexp -> exp
Rule 47    caseelement -> case COLON caseelementcontrol block SEMI_COLON
Rule 48    caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON
Rule 49    caseelementcontrol -> <empty>
Rule 50    case -> INTEGER
Rule 51    stmt -> RETURN exp
Rule 52    stmt -> exp
Rule 53    exp -> exp SUM exp
Rule 54    exp -> exp SUB exp
Rule 55    exp -> exp MUL exp
Rule 56    exp -> exp DIV exp
Rule 57    exp -> exp AND exp
Rule 58    exp -> exp OR exp
Rule 59    exp -> exp NE exp
Rule 60    exp -> exp EQ exp
Rule 61    exp -> exp LT exp
Rule 62    exp -> exp GT exp
Rule 63    exp -> exp LE exp
Rule 64    exp -> exp GE exp
Rule 65    exp -> OPEN_PAREN exp CLOSE_PAREN
Rule 66    exp -> REALNUMBER
Rule 67    exp -> INTEGER
Rule 68    exp -> TRUE
Rule 69    exp -> FALSE
Rule 70    exp -> lvalue
Rule 71    exp -> ID OPEN_PAREN explist CLOSE_PAREN
Rule 72    explist -> exp
Rule 73    explist -> explist SEPARATOR exp

Terminals, with rules where they appear

AND                  : 57
ASSIGN               : 13 32
BEGIN                : 27
BOOL                 : 11
CASE                 : 45
CLOSE_PAREN          : 19 21 38 65 71
COLON                : 21 47 48
DIV                  : 56
DO                   : 39 41 42
DOWNTO               : 42
ELSE                 : 35
END                  : 27 45
EQ                   : 60
FALSE                : 69
FOR                  : 41 42
FUNCTION             : 20
GE                   : 64
GT                   : 62
ID                   : 1 12 13 19 20 25 26 31 38 71
IF                   : 34 35
INT                  : 9
INTEGER              : 50 67
LE                   : 63
LT                   : 61
MUL                  : 55
NE                   : 59
OPEN_PAREN           : 19 21 38 65 71
OR                   : 58
PRINT                : 38
PROCEDURE            : 19
PROGRAM              : 1
REAL                 : 10
REALNUMBER           : 66
RETURN               : 51
SEMI_COLON           : 1 1 16 19 21 23 30 47 48
SEPARATOR            : 15 26 73
SUB                  : 54
SUM                  : 53
THEN                 : 34 35
TO                   : 41
TRUE                 : 68
WHILE                : 39
error                : 

Nonterminals, with rules where they appear

assignstmt           : 33 41 42
block                : 1 19 21 34 35 35 39 41 42 47 48
case                 : 47 48
caseelement          : 45 48
caseelementcontrol   : 47 48
controlcaseexp       : 45
controlelse          : 35
controlfordownexp    : 42
controlforupexp      : 41
controlifexp         : 34 35
controlwhileexp      : 39
dec                  : 4 5
declist              : 2 5
declistlast          : 1 19 21
exp                  : 13 32 36 40 43 44 46 51 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 72 73
explist              : 71 73
funcdec              : 8
funcname             : 21
iddec                : 14 15
idlist               : 15 16
lvalue               : 32 70
paramdec             : 22 23
paramdecs            : 17 23
paramdecslast        : 19 21
paramlist            : 24 26
procdec              : 7
program              : 0
stmt                 : 28 29 30
stmtlist             : 27 30
type                 : 16 21 24
vardec               : 6

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMI_COLON declistlast block SEMI_COLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMI_COLON declistlast block SEMI_COLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMI_COLON declistlast block SEMI_COLON

    SEMI_COLON      shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMI_COLON . declistlast block SEMI_COLON
    (2) declistlast -> . declist
    (3) declistlast -> .
    (4) declist -> . dec
    (5) declist -> . declist dec
    (6) dec -> . vardec
    (7) dec -> . procdec
    (8) dec -> . funcdec
    (16) vardec -> . type idlist SEMI_COLON
    (19) procdec -> . PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
    (21) funcdec -> . funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL
    (20) funcname -> . FUNCTION ID

    BEGIN           reduce using rule 3 (declistlast -> .)
    IF              reduce using rule 3 (declistlast -> .)
    PRINT           reduce using rule 3 (declistlast -> .)
    WHILE           reduce using rule 3 (declistlast -> .)
    FOR             reduce using rule 3 (declistlast -> .)
    CASE            reduce using rule 3 (declistlast -> .)
    RETURN          reduce using rule 3 (declistlast -> .)
    OPEN_PAREN      reduce using rule 3 (declistlast -> .)
    REALNUMBER      reduce using rule 3 (declistlast -> .)
    INTEGER         reduce using rule 3 (declistlast -> .)
    TRUE            reduce using rule 3 (declistlast -> .)
    FALSE           reduce using rule 3 (declistlast -> .)
    ID              reduce using rule 3 (declistlast -> .)
    PROCEDURE       shift and go to state 12
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16
    FUNCTION        shift and go to state 17

    declistlast                    shift and go to state 5
    declist                        shift and go to state 6
    dec                            shift and go to state 7
    vardec                         shift and go to state 8
    procdec                        shift and go to state 9
    funcdec                        shift and go to state 10
    type                           shift and go to state 11
    funcname                       shift and go to state 13

state 5

    (1) program -> PROGRAM ID SEMI_COLON declistlast . block SEMI_COLON
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 19
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 6

    (2) declistlast -> declist .
    (5) declist -> declist . dec
    (6) dec -> . vardec
    (7) dec -> . procdec
    (8) dec -> . funcdec
    (16) vardec -> . type idlist SEMI_COLON
    (19) procdec -> . PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
    (21) funcdec -> . funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL
    (20) funcname -> . FUNCTION ID

    BEGIN           reduce using rule 2 (declistlast -> declist .)
    IF              reduce using rule 2 (declistlast -> declist .)
    PRINT           reduce using rule 2 (declistlast -> declist .)
    WHILE           reduce using rule 2 (declistlast -> declist .)
    FOR             reduce using rule 2 (declistlast -> declist .)
    CASE            reduce using rule 2 (declistlast -> declist .)
    RETURN          reduce using rule 2 (declistlast -> declist .)
    OPEN_PAREN      reduce using rule 2 (declistlast -> declist .)
    REALNUMBER      reduce using rule 2 (declistlast -> declist .)
    INTEGER         reduce using rule 2 (declistlast -> declist .)
    TRUE            reduce using rule 2 (declistlast -> declist .)
    FALSE           reduce using rule 2 (declistlast -> declist .)
    ID              reduce using rule 2 (declistlast -> declist .)
    PROCEDURE       shift and go to state 12
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16
    FUNCTION        shift and go to state 17

    dec                            shift and go to state 36
    vardec                         shift and go to state 8
    procdec                        shift and go to state 9
    funcdec                        shift and go to state 10
    type                           shift and go to state 11
    funcname                       shift and go to state 13

state 7

    (4) declist -> dec .

    PROCEDURE       reduce using rule 4 (declist -> dec .)
    INT             reduce using rule 4 (declist -> dec .)
    REAL            reduce using rule 4 (declist -> dec .)
    BOOL            reduce using rule 4 (declist -> dec .)
    FUNCTION        reduce using rule 4 (declist -> dec .)
    BEGIN           reduce using rule 4 (declist -> dec .)
    IF              reduce using rule 4 (declist -> dec .)
    PRINT           reduce using rule 4 (declist -> dec .)
    WHILE           reduce using rule 4 (declist -> dec .)
    FOR             reduce using rule 4 (declist -> dec .)
    CASE            reduce using rule 4 (declist -> dec .)
    RETURN          reduce using rule 4 (declist -> dec .)
    OPEN_PAREN      reduce using rule 4 (declist -> dec .)
    REALNUMBER      reduce using rule 4 (declist -> dec .)
    INTEGER         reduce using rule 4 (declist -> dec .)
    TRUE            reduce using rule 4 (declist -> dec .)
    FALSE           reduce using rule 4 (declist -> dec .)
    ID              reduce using rule 4 (declist -> dec .)


state 8

    (6) dec -> vardec .

    PROCEDURE       reduce using rule 6 (dec -> vardec .)
    INT             reduce using rule 6 (dec -> vardec .)
    REAL            reduce using rule 6 (dec -> vardec .)
    BOOL            reduce using rule 6 (dec -> vardec .)
    FUNCTION        reduce using rule 6 (dec -> vardec .)
    BEGIN           reduce using rule 6 (dec -> vardec .)
    IF              reduce using rule 6 (dec -> vardec .)
    PRINT           reduce using rule 6 (dec -> vardec .)
    WHILE           reduce using rule 6 (dec -> vardec .)
    FOR             reduce using rule 6 (dec -> vardec .)
    CASE            reduce using rule 6 (dec -> vardec .)
    RETURN          reduce using rule 6 (dec -> vardec .)
    OPEN_PAREN      reduce using rule 6 (dec -> vardec .)
    REALNUMBER      reduce using rule 6 (dec -> vardec .)
    INTEGER         reduce using rule 6 (dec -> vardec .)
    TRUE            reduce using rule 6 (dec -> vardec .)
    FALSE           reduce using rule 6 (dec -> vardec .)
    ID              reduce using rule 6 (dec -> vardec .)


state 9

    (7) dec -> procdec .

    PROCEDURE       reduce using rule 7 (dec -> procdec .)
    INT             reduce using rule 7 (dec -> procdec .)
    REAL            reduce using rule 7 (dec -> procdec .)
    BOOL            reduce using rule 7 (dec -> procdec .)
    FUNCTION        reduce using rule 7 (dec -> procdec .)
    BEGIN           reduce using rule 7 (dec -> procdec .)
    IF              reduce using rule 7 (dec -> procdec .)
    PRINT           reduce using rule 7 (dec -> procdec .)
    WHILE           reduce using rule 7 (dec -> procdec .)
    FOR             reduce using rule 7 (dec -> procdec .)
    CASE            reduce using rule 7 (dec -> procdec .)
    RETURN          reduce using rule 7 (dec -> procdec .)
    OPEN_PAREN      reduce using rule 7 (dec -> procdec .)
    REALNUMBER      reduce using rule 7 (dec -> procdec .)
    INTEGER         reduce using rule 7 (dec -> procdec .)
    TRUE            reduce using rule 7 (dec -> procdec .)
    FALSE           reduce using rule 7 (dec -> procdec .)
    ID              reduce using rule 7 (dec -> procdec .)


state 10

    (8) dec -> funcdec .

    PROCEDURE       reduce using rule 8 (dec -> funcdec .)
    INT             reduce using rule 8 (dec -> funcdec .)
    REAL            reduce using rule 8 (dec -> funcdec .)
    BOOL            reduce using rule 8 (dec -> funcdec .)
    FUNCTION        reduce using rule 8 (dec -> funcdec .)
    BEGIN           reduce using rule 8 (dec -> funcdec .)
    IF              reduce using rule 8 (dec -> funcdec .)
    PRINT           reduce using rule 8 (dec -> funcdec .)
    WHILE           reduce using rule 8 (dec -> funcdec .)
    FOR             reduce using rule 8 (dec -> funcdec .)
    CASE            reduce using rule 8 (dec -> funcdec .)
    RETURN          reduce using rule 8 (dec -> funcdec .)
    OPEN_PAREN      reduce using rule 8 (dec -> funcdec .)
    REALNUMBER      reduce using rule 8 (dec -> funcdec .)
    INTEGER         reduce using rule 8 (dec -> funcdec .)
    TRUE            reduce using rule 8 (dec -> funcdec .)
    FALSE           reduce using rule 8 (dec -> funcdec .)
    ID              reduce using rule 8 (dec -> funcdec .)


state 11

    (16) vardec -> type . idlist SEMI_COLON
    (14) idlist -> . iddec
    (15) idlist -> . idlist SEPARATOR iddec
    (12) iddec -> . ID
    (13) iddec -> . ID ASSIGN exp

    ID              shift and go to state 39

    idlist                         shift and go to state 37
    iddec                          shift and go to state 38

state 12

    (19) procdec -> PROCEDURE . ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON

    ID              shift and go to state 40


state 13

    (21) funcdec -> funcname . OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON

    OPEN_PAREN      shift and go to state 41


state 14

    (9) type -> INT .

    ID              reduce using rule 9 (type -> INT .)
    PROCEDURE       reduce using rule 9 (type -> INT .)
    INT             reduce using rule 9 (type -> INT .)
    REAL            reduce using rule 9 (type -> INT .)
    BOOL            reduce using rule 9 (type -> INT .)
    FUNCTION        reduce using rule 9 (type -> INT .)
    BEGIN           reduce using rule 9 (type -> INT .)
    IF              reduce using rule 9 (type -> INT .)
    PRINT           reduce using rule 9 (type -> INT .)
    WHILE           reduce using rule 9 (type -> INT .)
    FOR             reduce using rule 9 (type -> INT .)
    CASE            reduce using rule 9 (type -> INT .)
    RETURN          reduce using rule 9 (type -> INT .)
    OPEN_PAREN      reduce using rule 9 (type -> INT .)
    REALNUMBER      reduce using rule 9 (type -> INT .)
    INTEGER         reduce using rule 9 (type -> INT .)
    TRUE            reduce using rule 9 (type -> INT .)
    FALSE           reduce using rule 9 (type -> INT .)


state 15

    (10) type -> REAL .

    ID              reduce using rule 10 (type -> REAL .)
    PROCEDURE       reduce using rule 10 (type -> REAL .)
    INT             reduce using rule 10 (type -> REAL .)
    REAL            reduce using rule 10 (type -> REAL .)
    BOOL            reduce using rule 10 (type -> REAL .)
    FUNCTION        reduce using rule 10 (type -> REAL .)
    BEGIN           reduce using rule 10 (type -> REAL .)
    IF              reduce using rule 10 (type -> REAL .)
    PRINT           reduce using rule 10 (type -> REAL .)
    WHILE           reduce using rule 10 (type -> REAL .)
    FOR             reduce using rule 10 (type -> REAL .)
    CASE            reduce using rule 10 (type -> REAL .)
    RETURN          reduce using rule 10 (type -> REAL .)
    OPEN_PAREN      reduce using rule 10 (type -> REAL .)
    REALNUMBER      reduce using rule 10 (type -> REAL .)
    INTEGER         reduce using rule 10 (type -> REAL .)
    TRUE            reduce using rule 10 (type -> REAL .)
    FALSE           reduce using rule 10 (type -> REAL .)


state 16

    (11) type -> BOOL .

    ID              reduce using rule 11 (type -> BOOL .)
    PROCEDURE       reduce using rule 11 (type -> BOOL .)
    INT             reduce using rule 11 (type -> BOOL .)
    REAL            reduce using rule 11 (type -> BOOL .)
    BOOL            reduce using rule 11 (type -> BOOL .)
    FUNCTION        reduce using rule 11 (type -> BOOL .)
    BEGIN           reduce using rule 11 (type -> BOOL .)
    IF              reduce using rule 11 (type -> BOOL .)
    PRINT           reduce using rule 11 (type -> BOOL .)
    WHILE           reduce using rule 11 (type -> BOOL .)
    FOR             reduce using rule 11 (type -> BOOL .)
    CASE            reduce using rule 11 (type -> BOOL .)
    RETURN          reduce using rule 11 (type -> BOOL .)
    OPEN_PAREN      reduce using rule 11 (type -> BOOL .)
    REALNUMBER      reduce using rule 11 (type -> BOOL .)
    INTEGER         reduce using rule 11 (type -> BOOL .)
    TRUE            reduce using rule 11 (type -> BOOL .)
    FALSE           reduce using rule 11 (type -> BOOL .)


state 17

    (20) funcname -> FUNCTION . ID

    ID              shift and go to state 42


state 18

    (71) exp -> ID . OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> ID .

    OPEN_PAREN      shift and go to state 43
    ASSIGN          reduce using rule 31 (lvalue -> ID .)
    SUM             reduce using rule 31 (lvalue -> ID .)
    SUB             reduce using rule 31 (lvalue -> ID .)
    MUL             reduce using rule 31 (lvalue -> ID .)
    DIV             reduce using rule 31 (lvalue -> ID .)
    AND             reduce using rule 31 (lvalue -> ID .)
    OR              reduce using rule 31 (lvalue -> ID .)
    NE              reduce using rule 31 (lvalue -> ID .)
    EQ              reduce using rule 31 (lvalue -> ID .)
    LT              reduce using rule 31 (lvalue -> ID .)
    GT              reduce using rule 31 (lvalue -> ID .)
    LE              reduce using rule 31 (lvalue -> ID .)
    GE              reduce using rule 31 (lvalue -> ID .)
    SEMI_COLON      reduce using rule 31 (lvalue -> ID .)
    END             reduce using rule 31 (lvalue -> ID .)
    THEN            reduce using rule 31 (lvalue -> ID .)
    CLOSE_PAREN     reduce using rule 31 (lvalue -> ID .)
    DO              reduce using rule 31 (lvalue -> ID .)
    INTEGER         reduce using rule 31 (lvalue -> ID .)
    ELSE            reduce using rule 31 (lvalue -> ID .)
    SEPARATOR       reduce using rule 31 (lvalue -> ID .)
    TO              reduce using rule 31 (lvalue -> ID .)
    DOWNTO          reduce using rule 31 (lvalue -> ID .)


state 19

    (1) program -> PROGRAM ID SEMI_COLON declistlast block . SEMI_COLON

    SEMI_COLON      shift and go to state 44


state 20

    (27) block -> BEGIN . stmtlist END
    (29) stmtlist -> . stmt
    (30) stmtlist -> . stmtlist SEMI_COLON stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    stmtlist                       shift and go to state 45
    stmt                           shift and go to state 46
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 21

    (28) block -> stmt .

    SEMI_COLON      reduce using rule 28 (block -> stmt .)
    ELSE            reduce using rule 28 (block -> stmt .)
    END             reduce using rule 28 (block -> stmt .)


state 22

    (33) stmt -> assignstmt .

    SEMI_COLON      reduce using rule 33 (stmt -> assignstmt .)
    END             reduce using rule 33 (stmt -> assignstmt .)
    ELSE            reduce using rule 33 (stmt -> assignstmt .)


state 23

    (34) stmt -> IF . controlifexp THEN block
    (35) stmt -> IF . controlifexp THEN block ELSE controlelse block
    (36) controlifexp -> . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    controlifexp                   shift and go to state 47
    exp                            shift and go to state 48
    lvalue                         shift and go to state 49

state 24

    (38) stmt -> PRINT . OPEN_PAREN ID CLOSE_PAREN

    OPEN_PAREN      shift and go to state 50


state 25

    (65) exp -> OPEN_PAREN . exp CLOSE_PAREN
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 51
    lvalue                         shift and go to state 49

state 26

    (39) stmt -> WHILE . controlwhileexp DO block
    (40) controlwhileexp -> . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    controlwhileexp                shift and go to state 52
    exp                            shift and go to state 53
    lvalue                         shift and go to state 49

state 27

    (41) stmt -> FOR . assignstmt TO controlforupexp DO block
    (42) stmt -> FOR . assignstmt DOWNTO controlfordownexp DO block
    (32) assignstmt -> . lvalue ASSIGN exp
    (31) lvalue -> . ID

    ID              shift and go to state 56

    assignstmt                     shift and go to state 54
    lvalue                         shift and go to state 55

state 28

    (45) stmt -> CASE . controlcaseexp caseelement END
    (46) controlcaseexp -> . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    controlcaseexp                 shift and go to state 57
    exp                            shift and go to state 58
    lvalue                         shift and go to state 49

state 29

    (51) stmt -> RETURN . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 59
    lvalue                         shift and go to state 49

state 30

    (52) stmt -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 52 (stmt -> exp .)
    END             reduce using rule 52 (stmt -> exp .)
    ELSE            reduce using rule 52 (stmt -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 31

    (32) assignstmt -> lvalue . ASSIGN exp
    (70) exp -> lvalue .

    ASSIGN          shift and go to state 72
    SUM             reduce using rule 70 (exp -> lvalue .)
    SUB             reduce using rule 70 (exp -> lvalue .)
    MUL             reduce using rule 70 (exp -> lvalue .)
    DIV             reduce using rule 70 (exp -> lvalue .)
    AND             reduce using rule 70 (exp -> lvalue .)
    OR              reduce using rule 70 (exp -> lvalue .)
    NE              reduce using rule 70 (exp -> lvalue .)
    EQ              reduce using rule 70 (exp -> lvalue .)
    LT              reduce using rule 70 (exp -> lvalue .)
    GT              reduce using rule 70 (exp -> lvalue .)
    LE              reduce using rule 70 (exp -> lvalue .)
    GE              reduce using rule 70 (exp -> lvalue .)
    SEMI_COLON      reduce using rule 70 (exp -> lvalue .)
    END             reduce using rule 70 (exp -> lvalue .)
    ELSE            reduce using rule 70 (exp -> lvalue .)


state 32

    (66) exp -> REALNUMBER .

    SUM             reduce using rule 66 (exp -> REALNUMBER .)
    SUB             reduce using rule 66 (exp -> REALNUMBER .)
    MUL             reduce using rule 66 (exp -> REALNUMBER .)
    DIV             reduce using rule 66 (exp -> REALNUMBER .)
    AND             reduce using rule 66 (exp -> REALNUMBER .)
    OR              reduce using rule 66 (exp -> REALNUMBER .)
    NE              reduce using rule 66 (exp -> REALNUMBER .)
    EQ              reduce using rule 66 (exp -> REALNUMBER .)
    LT              reduce using rule 66 (exp -> REALNUMBER .)
    GT              reduce using rule 66 (exp -> REALNUMBER .)
    LE              reduce using rule 66 (exp -> REALNUMBER .)
    GE              reduce using rule 66 (exp -> REALNUMBER .)
    SEMI_COLON      reduce using rule 66 (exp -> REALNUMBER .)
    END             reduce using rule 66 (exp -> REALNUMBER .)
    THEN            reduce using rule 66 (exp -> REALNUMBER .)
    CLOSE_PAREN     reduce using rule 66 (exp -> REALNUMBER .)
    DO              reduce using rule 66 (exp -> REALNUMBER .)
    INTEGER         reduce using rule 66 (exp -> REALNUMBER .)
    ELSE            reduce using rule 66 (exp -> REALNUMBER .)
    SEPARATOR       reduce using rule 66 (exp -> REALNUMBER .)
    TO              reduce using rule 66 (exp -> REALNUMBER .)
    DOWNTO          reduce using rule 66 (exp -> REALNUMBER .)


state 33

    (67) exp -> INTEGER .

    SUM             reduce using rule 67 (exp -> INTEGER .)
    SUB             reduce using rule 67 (exp -> INTEGER .)
    MUL             reduce using rule 67 (exp -> INTEGER .)
    DIV             reduce using rule 67 (exp -> INTEGER .)
    AND             reduce using rule 67 (exp -> INTEGER .)
    OR              reduce using rule 67 (exp -> INTEGER .)
    NE              reduce using rule 67 (exp -> INTEGER .)
    EQ              reduce using rule 67 (exp -> INTEGER .)
    LT              reduce using rule 67 (exp -> INTEGER .)
    GT              reduce using rule 67 (exp -> INTEGER .)
    LE              reduce using rule 67 (exp -> INTEGER .)
    GE              reduce using rule 67 (exp -> INTEGER .)
    SEMI_COLON      reduce using rule 67 (exp -> INTEGER .)
    END             reduce using rule 67 (exp -> INTEGER .)
    THEN            reduce using rule 67 (exp -> INTEGER .)
    CLOSE_PAREN     reduce using rule 67 (exp -> INTEGER .)
    DO              reduce using rule 67 (exp -> INTEGER .)
    INTEGER         reduce using rule 67 (exp -> INTEGER .)
    ELSE            reduce using rule 67 (exp -> INTEGER .)
    SEPARATOR       reduce using rule 67 (exp -> INTEGER .)
    TO              reduce using rule 67 (exp -> INTEGER .)
    DOWNTO          reduce using rule 67 (exp -> INTEGER .)


state 34

    (68) exp -> TRUE .

    SUM             reduce using rule 68 (exp -> TRUE .)
    SUB             reduce using rule 68 (exp -> TRUE .)
    MUL             reduce using rule 68 (exp -> TRUE .)
    DIV             reduce using rule 68 (exp -> TRUE .)
    AND             reduce using rule 68 (exp -> TRUE .)
    OR              reduce using rule 68 (exp -> TRUE .)
    NE              reduce using rule 68 (exp -> TRUE .)
    EQ              reduce using rule 68 (exp -> TRUE .)
    LT              reduce using rule 68 (exp -> TRUE .)
    GT              reduce using rule 68 (exp -> TRUE .)
    LE              reduce using rule 68 (exp -> TRUE .)
    GE              reduce using rule 68 (exp -> TRUE .)
    SEMI_COLON      reduce using rule 68 (exp -> TRUE .)
    END             reduce using rule 68 (exp -> TRUE .)
    THEN            reduce using rule 68 (exp -> TRUE .)
    CLOSE_PAREN     reduce using rule 68 (exp -> TRUE .)
    DO              reduce using rule 68 (exp -> TRUE .)
    INTEGER         reduce using rule 68 (exp -> TRUE .)
    ELSE            reduce using rule 68 (exp -> TRUE .)
    SEPARATOR       reduce using rule 68 (exp -> TRUE .)
    TO              reduce using rule 68 (exp -> TRUE .)
    DOWNTO          reduce using rule 68 (exp -> TRUE .)


state 35

    (69) exp -> FALSE .

    SUM             reduce using rule 69 (exp -> FALSE .)
    SUB             reduce using rule 69 (exp -> FALSE .)
    MUL             reduce using rule 69 (exp -> FALSE .)
    DIV             reduce using rule 69 (exp -> FALSE .)
    AND             reduce using rule 69 (exp -> FALSE .)
    OR              reduce using rule 69 (exp -> FALSE .)
    NE              reduce using rule 69 (exp -> FALSE .)
    EQ              reduce using rule 69 (exp -> FALSE .)
    LT              reduce using rule 69 (exp -> FALSE .)
    GT              reduce using rule 69 (exp -> FALSE .)
    LE              reduce using rule 69 (exp -> FALSE .)
    GE              reduce using rule 69 (exp -> FALSE .)
    SEMI_COLON      reduce using rule 69 (exp -> FALSE .)
    END             reduce using rule 69 (exp -> FALSE .)
    THEN            reduce using rule 69 (exp -> FALSE .)
    CLOSE_PAREN     reduce using rule 69 (exp -> FALSE .)
    DO              reduce using rule 69 (exp -> FALSE .)
    INTEGER         reduce using rule 69 (exp -> FALSE .)
    ELSE            reduce using rule 69 (exp -> FALSE .)
    SEPARATOR       reduce using rule 69 (exp -> FALSE .)
    TO              reduce using rule 69 (exp -> FALSE .)
    DOWNTO          reduce using rule 69 (exp -> FALSE .)


state 36

    (5) declist -> declist dec .

    PROCEDURE       reduce using rule 5 (declist -> declist dec .)
    INT             reduce using rule 5 (declist -> declist dec .)
    REAL            reduce using rule 5 (declist -> declist dec .)
    BOOL            reduce using rule 5 (declist -> declist dec .)
    FUNCTION        reduce using rule 5 (declist -> declist dec .)
    BEGIN           reduce using rule 5 (declist -> declist dec .)
    IF              reduce using rule 5 (declist -> declist dec .)
    PRINT           reduce using rule 5 (declist -> declist dec .)
    WHILE           reduce using rule 5 (declist -> declist dec .)
    FOR             reduce using rule 5 (declist -> declist dec .)
    CASE            reduce using rule 5 (declist -> declist dec .)
    RETURN          reduce using rule 5 (declist -> declist dec .)
    OPEN_PAREN      reduce using rule 5 (declist -> declist dec .)
    REALNUMBER      reduce using rule 5 (declist -> declist dec .)
    INTEGER         reduce using rule 5 (declist -> declist dec .)
    TRUE            reduce using rule 5 (declist -> declist dec .)
    FALSE           reduce using rule 5 (declist -> declist dec .)
    ID              reduce using rule 5 (declist -> declist dec .)


state 37

    (16) vardec -> type idlist . SEMI_COLON
    (15) idlist -> idlist . SEPARATOR iddec

    SEMI_COLON      shift and go to state 73
    SEPARATOR       shift and go to state 74


state 38

    (14) idlist -> iddec .

    SEMI_COLON      reduce using rule 14 (idlist -> iddec .)
    SEPARATOR       reduce using rule 14 (idlist -> iddec .)


state 39

    (12) iddec -> ID .
    (13) iddec -> ID . ASSIGN exp

    SEMI_COLON      reduce using rule 12 (iddec -> ID .)
    SEPARATOR       reduce using rule 12 (iddec -> ID .)
    ASSIGN          shift and go to state 75


state 40

    (19) procdec -> PROCEDURE ID . OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON

    OPEN_PAREN      shift and go to state 76


state 41

    (21) funcdec -> funcname OPEN_PAREN . paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
    (17) paramdecslast -> . paramdecs
    (18) paramdecslast -> .
    (22) paramdecs -> . paramdec
    (23) paramdecs -> . paramdecs SEMI_COLON paramdec
    (24) paramdec -> . type paramlist
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL

    CLOSE_PAREN     reduce using rule 18 (paramdecslast -> .)
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16

    paramdecslast                  shift and go to state 77
    type                           shift and go to state 78
    paramdecs                      shift and go to state 79
    paramdec                       shift and go to state 80

state 42

    (20) funcname -> FUNCTION ID .

    OPEN_PAREN      reduce using rule 20 (funcname -> FUNCTION ID .)


state 43

    (71) exp -> ID OPEN_PAREN . explist CLOSE_PAREN
    (72) explist -> . exp
    (73) explist -> . explist SEPARATOR exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    explist                        shift and go to state 81
    exp                            shift and go to state 82
    lvalue                         shift and go to state 49

state 44

    (1) program -> PROGRAM ID SEMI_COLON declistlast block SEMI_COLON .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMI_COLON declistlast block SEMI_COLON .)


state 45

    (27) block -> BEGIN stmtlist . END
    (30) stmtlist -> stmtlist . SEMI_COLON stmt

    END             shift and go to state 83
    SEMI_COLON      shift and go to state 84


state 46

    (29) stmtlist -> stmt .

    END             reduce using rule 29 (stmtlist -> stmt .)
    SEMI_COLON      reduce using rule 29 (stmtlist -> stmt .)


state 47

    (34) stmt -> IF controlifexp . THEN block
    (35) stmt -> IF controlifexp . THEN block ELSE controlelse block

    THEN            shift and go to state 85


state 48

    (36) controlifexp -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    THEN            reduce using rule 36 (controlifexp -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 49

    (70) exp -> lvalue .

    SUM             reduce using rule 70 (exp -> lvalue .)
    SUB             reduce using rule 70 (exp -> lvalue .)
    MUL             reduce using rule 70 (exp -> lvalue .)
    DIV             reduce using rule 70 (exp -> lvalue .)
    AND             reduce using rule 70 (exp -> lvalue .)
    OR              reduce using rule 70 (exp -> lvalue .)
    NE              reduce using rule 70 (exp -> lvalue .)
    EQ              reduce using rule 70 (exp -> lvalue .)
    LT              reduce using rule 70 (exp -> lvalue .)
    GT              reduce using rule 70 (exp -> lvalue .)
    LE              reduce using rule 70 (exp -> lvalue .)
    GE              reduce using rule 70 (exp -> lvalue .)
    THEN            reduce using rule 70 (exp -> lvalue .)
    CLOSE_PAREN     reduce using rule 70 (exp -> lvalue .)
    DO              reduce using rule 70 (exp -> lvalue .)
    INTEGER         reduce using rule 70 (exp -> lvalue .)
    SEMI_COLON      reduce using rule 70 (exp -> lvalue .)
    END             reduce using rule 70 (exp -> lvalue .)
    ELSE            reduce using rule 70 (exp -> lvalue .)
    SEPARATOR       reduce using rule 70 (exp -> lvalue .)
    TO              reduce using rule 70 (exp -> lvalue .)
    DOWNTO          reduce using rule 70 (exp -> lvalue .)


state 50

    (38) stmt -> PRINT OPEN_PAREN . ID CLOSE_PAREN

    ID              shift and go to state 86


state 51

    (65) exp -> OPEN_PAREN exp . CLOSE_PAREN
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    CLOSE_PAREN     shift and go to state 87
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 52

    (39) stmt -> WHILE controlwhileexp . DO block

    DO              shift and go to state 88


state 53

    (40) controlwhileexp -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    DO              reduce using rule 40 (controlwhileexp -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 54

    (41) stmt -> FOR assignstmt . TO controlforupexp DO block
    (42) stmt -> FOR assignstmt . DOWNTO controlfordownexp DO block

    TO              shift and go to state 89
    DOWNTO          shift and go to state 90


state 55

    (32) assignstmt -> lvalue . ASSIGN exp

    ASSIGN          shift and go to state 72


state 56

    (31) lvalue -> ID .

    ASSIGN          reduce using rule 31 (lvalue -> ID .)


state 57

    (45) stmt -> CASE controlcaseexp . caseelement END
    (47) caseelement -> . case COLON caseelementcontrol block SEMI_COLON
    (48) caseelement -> . caseelement case COLON caseelementcontrol block SEMI_COLON
    (50) case -> . INTEGER

    INTEGER         shift and go to state 93

    caseelement                    shift and go to state 91
    case                           shift and go to state 92

state 58

    (46) controlcaseexp -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    INTEGER         reduce using rule 46 (controlcaseexp -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 59

    (51) stmt -> RETURN exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 51 (stmt -> RETURN exp .)
    END             reduce using rule 51 (stmt -> RETURN exp .)
    ELSE            reduce using rule 51 (stmt -> RETURN exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 60

    (53) exp -> exp SUM . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 94
    lvalue                         shift and go to state 49

state 61

    (54) exp -> exp SUB . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 95
    lvalue                         shift and go to state 49

state 62

    (55) exp -> exp MUL . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 96
    lvalue                         shift and go to state 49

state 63

    (56) exp -> exp DIV . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 97
    lvalue                         shift and go to state 49

state 64

    (57) exp -> exp AND . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 98
    lvalue                         shift and go to state 49

state 65

    (58) exp -> exp OR . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 99
    lvalue                         shift and go to state 49

state 66

    (59) exp -> exp NE . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 100
    lvalue                         shift and go to state 49

state 67

    (60) exp -> exp EQ . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 101
    lvalue                         shift and go to state 49

state 68

    (61) exp -> exp LT . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 102
    lvalue                         shift and go to state 49

state 69

    (62) exp -> exp GT . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 103
    lvalue                         shift and go to state 49

state 70

    (63) exp -> exp LE . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 104
    lvalue                         shift and go to state 49

state 71

    (64) exp -> exp GE . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 105
    lvalue                         shift and go to state 49

state 72

    (32) assignstmt -> lvalue ASSIGN . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    lvalue                         shift and go to state 49
    exp                            shift and go to state 106

state 73

    (16) vardec -> type idlist SEMI_COLON .

    PROCEDURE       reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    INT             reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    REAL            reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    BOOL            reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    FUNCTION        reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    BEGIN           reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    IF              reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    PRINT           reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    WHILE           reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    FOR             reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    CASE            reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    RETURN          reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    OPEN_PAREN      reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    REALNUMBER      reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    INTEGER         reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    TRUE            reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    FALSE           reduce using rule 16 (vardec -> type idlist SEMI_COLON .)
    ID              reduce using rule 16 (vardec -> type idlist SEMI_COLON .)


state 74

    (15) idlist -> idlist SEPARATOR . iddec
    (12) iddec -> . ID
    (13) iddec -> . ID ASSIGN exp

    ID              shift and go to state 39

    iddec                          shift and go to state 107

state 75

    (13) iddec -> ID ASSIGN . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 108
    lvalue                         shift and go to state 49

state 76

    (19) procdec -> PROCEDURE ID OPEN_PAREN . paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
    (17) paramdecslast -> . paramdecs
    (18) paramdecslast -> .
    (22) paramdecs -> . paramdec
    (23) paramdecs -> . paramdecs SEMI_COLON paramdec
    (24) paramdec -> . type paramlist
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL

    CLOSE_PAREN     reduce using rule 18 (paramdecslast -> .)
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16

    paramdecslast                  shift and go to state 109
    paramdecs                      shift and go to state 79
    paramdec                       shift and go to state 80
    type                           shift and go to state 78

state 77

    (21) funcdec -> funcname OPEN_PAREN paramdecslast . CLOSE_PAREN COLON type declistlast block SEMI_COLON

    CLOSE_PAREN     shift and go to state 110


state 78

    (24) paramdec -> type . paramlist
    (25) paramlist -> . ID
    (26) paramlist -> . paramlist SEPARATOR ID

    ID              shift and go to state 112

    paramlist                      shift and go to state 111

state 79

    (17) paramdecslast -> paramdecs .
    (23) paramdecs -> paramdecs . SEMI_COLON paramdec

    CLOSE_PAREN     reduce using rule 17 (paramdecslast -> paramdecs .)
    SEMI_COLON      shift and go to state 113


state 80

    (22) paramdecs -> paramdec .

    SEMI_COLON      reduce using rule 22 (paramdecs -> paramdec .)
    CLOSE_PAREN     reduce using rule 22 (paramdecs -> paramdec .)


state 81

    (71) exp -> ID OPEN_PAREN explist . CLOSE_PAREN
    (73) explist -> explist . SEPARATOR exp

    CLOSE_PAREN     shift and go to state 114
    SEPARATOR       shift and go to state 115


state 82

    (72) explist -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    CLOSE_PAREN     reduce using rule 72 (explist -> exp .)
    SEPARATOR       reduce using rule 72 (explist -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 83

    (27) block -> BEGIN stmtlist END .

    SEMI_COLON      reduce using rule 27 (block -> BEGIN stmtlist END .)
    ELSE            reduce using rule 27 (block -> BEGIN stmtlist END .)
    END             reduce using rule 27 (block -> BEGIN stmtlist END .)


state 84

    (30) stmtlist -> stmtlist SEMI_COLON . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    stmt                           shift and go to state 116
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 85

    (34) stmt -> IF controlifexp THEN . block
    (35) stmt -> IF controlifexp THEN . block ELSE controlelse block
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 117
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 86

    (38) stmt -> PRINT OPEN_PAREN ID . CLOSE_PAREN

    CLOSE_PAREN     shift and go to state 118


state 87

    (65) exp -> OPEN_PAREN exp CLOSE_PAREN .

    SUM             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SUB             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    MUL             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DIV             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    AND             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    OR              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    NE              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    EQ              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    LT              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    GT              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    LE              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    GE              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    END             reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    THEN            reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DO              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    INTEGER         reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    ELSE            reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    SEPARATOR       reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    TO              reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)
    DOWNTO          reduce using rule 65 (exp -> OPEN_PAREN exp CLOSE_PAREN .)


state 88

    (39) stmt -> WHILE controlwhileexp DO . block
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 119
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 89

    (41) stmt -> FOR assignstmt TO . controlforupexp DO block
    (43) controlforupexp -> . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    controlforupexp                shift and go to state 120
    exp                            shift and go to state 121
    lvalue                         shift and go to state 49

state 90

    (42) stmt -> FOR assignstmt DOWNTO . controlfordownexp DO block
    (44) controlfordownexp -> . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    controlfordownexp              shift and go to state 122
    exp                            shift and go to state 123
    lvalue                         shift and go to state 49

state 91

    (45) stmt -> CASE controlcaseexp caseelement . END
    (48) caseelement -> caseelement . case COLON caseelementcontrol block SEMI_COLON
    (50) case -> . INTEGER

    END             shift and go to state 124
    INTEGER         shift and go to state 93

    case                           shift and go to state 125

state 92

    (47) caseelement -> case . COLON caseelementcontrol block SEMI_COLON

    COLON           shift and go to state 126


state 93

    (50) case -> INTEGER .

    COLON           reduce using rule 50 (case -> INTEGER .)


state 94

    (53) exp -> exp SUM exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SUM             reduce using rule 53 (exp -> exp SUM exp .)
    SUB             reduce using rule 53 (exp -> exp SUM exp .)
    AND             reduce using rule 53 (exp -> exp SUM exp .)
    OR              reduce using rule 53 (exp -> exp SUM exp .)
    NE              reduce using rule 53 (exp -> exp SUM exp .)
    EQ              reduce using rule 53 (exp -> exp SUM exp .)
    LT              reduce using rule 53 (exp -> exp SUM exp .)
    GT              reduce using rule 53 (exp -> exp SUM exp .)
    LE              reduce using rule 53 (exp -> exp SUM exp .)
    GE              reduce using rule 53 (exp -> exp SUM exp .)
    SEMI_COLON      reduce using rule 53 (exp -> exp SUM exp .)
    END             reduce using rule 53 (exp -> exp SUM exp .)
    THEN            reduce using rule 53 (exp -> exp SUM exp .)
    CLOSE_PAREN     reduce using rule 53 (exp -> exp SUM exp .)
    DO              reduce using rule 53 (exp -> exp SUM exp .)
    INTEGER         reduce using rule 53 (exp -> exp SUM exp .)
    ELSE            reduce using rule 53 (exp -> exp SUM exp .)
    SEPARATOR       reduce using rule 53 (exp -> exp SUM exp .)
    TO              reduce using rule 53 (exp -> exp SUM exp .)
    DOWNTO          reduce using rule 53 (exp -> exp SUM exp .)
    MUL             shift and go to state 62
    DIV             shift and go to state 63

  ! MUL             [ reduce using rule 53 (exp -> exp SUM exp .) ]
  ! DIV             [ reduce using rule 53 (exp -> exp SUM exp .) ]
  ! SUM             [ shift and go to state 60 ]
  ! SUB             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! LE              [ shift and go to state 70 ]
  ! GE              [ shift and go to state 71 ]


state 95

    (54) exp -> exp SUB exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SUM             reduce using rule 54 (exp -> exp SUB exp .)
    SUB             reduce using rule 54 (exp -> exp SUB exp .)
    AND             reduce using rule 54 (exp -> exp SUB exp .)
    OR              reduce using rule 54 (exp -> exp SUB exp .)
    NE              reduce using rule 54 (exp -> exp SUB exp .)
    EQ              reduce using rule 54 (exp -> exp SUB exp .)
    LT              reduce using rule 54 (exp -> exp SUB exp .)
    GT              reduce using rule 54 (exp -> exp SUB exp .)
    LE              reduce using rule 54 (exp -> exp SUB exp .)
    GE              reduce using rule 54 (exp -> exp SUB exp .)
    SEMI_COLON      reduce using rule 54 (exp -> exp SUB exp .)
    END             reduce using rule 54 (exp -> exp SUB exp .)
    THEN            reduce using rule 54 (exp -> exp SUB exp .)
    CLOSE_PAREN     reduce using rule 54 (exp -> exp SUB exp .)
    DO              reduce using rule 54 (exp -> exp SUB exp .)
    INTEGER         reduce using rule 54 (exp -> exp SUB exp .)
    ELSE            reduce using rule 54 (exp -> exp SUB exp .)
    SEPARATOR       reduce using rule 54 (exp -> exp SUB exp .)
    TO              reduce using rule 54 (exp -> exp SUB exp .)
    DOWNTO          reduce using rule 54 (exp -> exp SUB exp .)
    MUL             shift and go to state 62
    DIV             shift and go to state 63

  ! MUL             [ reduce using rule 54 (exp -> exp SUB exp .) ]
  ! DIV             [ reduce using rule 54 (exp -> exp SUB exp .) ]
  ! SUM             [ shift and go to state 60 ]
  ! SUB             [ shift and go to state 61 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! LE              [ shift and go to state 70 ]
  ! GE              [ shift and go to state 71 ]


state 96

    (55) exp -> exp MUL exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SUM             reduce using rule 55 (exp -> exp MUL exp .)
    SUB             reduce using rule 55 (exp -> exp MUL exp .)
    MUL             reduce using rule 55 (exp -> exp MUL exp .)
    DIV             reduce using rule 55 (exp -> exp MUL exp .)
    AND             reduce using rule 55 (exp -> exp MUL exp .)
    OR              reduce using rule 55 (exp -> exp MUL exp .)
    NE              reduce using rule 55 (exp -> exp MUL exp .)
    EQ              reduce using rule 55 (exp -> exp MUL exp .)
    LT              reduce using rule 55 (exp -> exp MUL exp .)
    GT              reduce using rule 55 (exp -> exp MUL exp .)
    LE              reduce using rule 55 (exp -> exp MUL exp .)
    GE              reduce using rule 55 (exp -> exp MUL exp .)
    SEMI_COLON      reduce using rule 55 (exp -> exp MUL exp .)
    END             reduce using rule 55 (exp -> exp MUL exp .)
    THEN            reduce using rule 55 (exp -> exp MUL exp .)
    CLOSE_PAREN     reduce using rule 55 (exp -> exp MUL exp .)
    DO              reduce using rule 55 (exp -> exp MUL exp .)
    INTEGER         reduce using rule 55 (exp -> exp MUL exp .)
    ELSE            reduce using rule 55 (exp -> exp MUL exp .)
    SEPARATOR       reduce using rule 55 (exp -> exp MUL exp .)
    TO              reduce using rule 55 (exp -> exp MUL exp .)
    DOWNTO          reduce using rule 55 (exp -> exp MUL exp .)

  ! SUM             [ shift and go to state 60 ]
  ! SUB             [ shift and go to state 61 ]
  ! MUL             [ shift and go to state 62 ]
  ! DIV             [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! LE              [ shift and go to state 70 ]
  ! GE              [ shift and go to state 71 ]


state 97

    (56) exp -> exp DIV exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SUM             reduce using rule 56 (exp -> exp DIV exp .)
    SUB             reduce using rule 56 (exp -> exp DIV exp .)
    MUL             reduce using rule 56 (exp -> exp DIV exp .)
    DIV             reduce using rule 56 (exp -> exp DIV exp .)
    AND             reduce using rule 56 (exp -> exp DIV exp .)
    OR              reduce using rule 56 (exp -> exp DIV exp .)
    NE              reduce using rule 56 (exp -> exp DIV exp .)
    EQ              reduce using rule 56 (exp -> exp DIV exp .)
    LT              reduce using rule 56 (exp -> exp DIV exp .)
    GT              reduce using rule 56 (exp -> exp DIV exp .)
    LE              reduce using rule 56 (exp -> exp DIV exp .)
    GE              reduce using rule 56 (exp -> exp DIV exp .)
    SEMI_COLON      reduce using rule 56 (exp -> exp DIV exp .)
    END             reduce using rule 56 (exp -> exp DIV exp .)
    THEN            reduce using rule 56 (exp -> exp DIV exp .)
    CLOSE_PAREN     reduce using rule 56 (exp -> exp DIV exp .)
    DO              reduce using rule 56 (exp -> exp DIV exp .)
    INTEGER         reduce using rule 56 (exp -> exp DIV exp .)
    ELSE            reduce using rule 56 (exp -> exp DIV exp .)
    SEPARATOR       reduce using rule 56 (exp -> exp DIV exp .)
    TO              reduce using rule 56 (exp -> exp DIV exp .)
    DOWNTO          reduce using rule 56 (exp -> exp DIV exp .)

  ! SUM             [ shift and go to state 60 ]
  ! SUB             [ shift and go to state 61 ]
  ! MUL             [ shift and go to state 62 ]
  ! DIV             [ shift and go to state 63 ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! LE              [ shift and go to state 70 ]
  ! GE              [ shift and go to state 71 ]


state 98

    (57) exp -> exp AND exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 57 (exp -> exp AND exp .)
    OR              reduce using rule 57 (exp -> exp AND exp .)
    SEMI_COLON      reduce using rule 57 (exp -> exp AND exp .)
    END             reduce using rule 57 (exp -> exp AND exp .)
    THEN            reduce using rule 57 (exp -> exp AND exp .)
    CLOSE_PAREN     reduce using rule 57 (exp -> exp AND exp .)
    DO              reduce using rule 57 (exp -> exp AND exp .)
    INTEGER         reduce using rule 57 (exp -> exp AND exp .)
    ELSE            reduce using rule 57 (exp -> exp AND exp .)
    SEPARATOR       reduce using rule 57 (exp -> exp AND exp .)
    TO              reduce using rule 57 (exp -> exp AND exp .)
    DOWNTO          reduce using rule 57 (exp -> exp AND exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71

  ! SUM             [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! SUB             [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! MUL             [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! DIV             [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! NE              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! EQ              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! LT              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! GT              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! LE              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! GE              [ reduce using rule 57 (exp -> exp AND exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]


state 99

    (58) exp -> exp OR exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    OR              reduce using rule 58 (exp -> exp OR exp .)
    SEMI_COLON      reduce using rule 58 (exp -> exp OR exp .)
    END             reduce using rule 58 (exp -> exp OR exp .)
    THEN            reduce using rule 58 (exp -> exp OR exp .)
    CLOSE_PAREN     reduce using rule 58 (exp -> exp OR exp .)
    DO              reduce using rule 58 (exp -> exp OR exp .)
    INTEGER         reduce using rule 58 (exp -> exp OR exp .)
    ELSE            reduce using rule 58 (exp -> exp OR exp .)
    SEPARATOR       reduce using rule 58 (exp -> exp OR exp .)
    TO              reduce using rule 58 (exp -> exp OR exp .)
    DOWNTO          reduce using rule 58 (exp -> exp OR exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71

  ! SUM             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! SUB             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! MUL             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! DIV             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! AND             [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! NE              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! EQ              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! LT              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! GT              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! LE              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! GE              [ reduce using rule 58 (exp -> exp OR exp .) ]
  ! OR              [ shift and go to state 65 ]


state 100

    (59) exp -> exp NE exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 59 (exp -> exp NE exp .)
    OR              reduce using rule 59 (exp -> exp NE exp .)
    NE              reduce using rule 59 (exp -> exp NE exp .)
    LT              reduce using rule 59 (exp -> exp NE exp .)
    GT              reduce using rule 59 (exp -> exp NE exp .)
    GE              reduce using rule 59 (exp -> exp NE exp .)
    SEMI_COLON      reduce using rule 59 (exp -> exp NE exp .)
    END             reduce using rule 59 (exp -> exp NE exp .)
    THEN            reduce using rule 59 (exp -> exp NE exp .)
    CLOSE_PAREN     reduce using rule 59 (exp -> exp NE exp .)
    DO              reduce using rule 59 (exp -> exp NE exp .)
    INTEGER         reduce using rule 59 (exp -> exp NE exp .)
    ELSE            reduce using rule 59 (exp -> exp NE exp .)
    SEPARATOR       reduce using rule 59 (exp -> exp NE exp .)
    TO              reduce using rule 59 (exp -> exp NE exp .)
    DOWNTO          reduce using rule 59 (exp -> exp NE exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    EQ              shift and go to state 67
    LE              shift and go to state 70

  ! SUM             [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! SUB             [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! MUL             [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! DIV             [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! EQ              [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! LE              [ reduce using rule 59 (exp -> exp NE exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! GE              [ shift and go to state 71 ]


state 101

    (60) exp -> exp EQ exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 60 (exp -> exp EQ exp .)
    OR              reduce using rule 60 (exp -> exp EQ exp .)
    NE              reduce using rule 60 (exp -> exp EQ exp .)
    EQ              reduce using rule 60 (exp -> exp EQ exp .)
    LT              reduce using rule 60 (exp -> exp EQ exp .)
    GT              reduce using rule 60 (exp -> exp EQ exp .)
    GE              reduce using rule 60 (exp -> exp EQ exp .)
    SEMI_COLON      reduce using rule 60 (exp -> exp EQ exp .)
    END             reduce using rule 60 (exp -> exp EQ exp .)
    THEN            reduce using rule 60 (exp -> exp EQ exp .)
    CLOSE_PAREN     reduce using rule 60 (exp -> exp EQ exp .)
    DO              reduce using rule 60 (exp -> exp EQ exp .)
    INTEGER         reduce using rule 60 (exp -> exp EQ exp .)
    ELSE            reduce using rule 60 (exp -> exp EQ exp .)
    SEPARATOR       reduce using rule 60 (exp -> exp EQ exp .)
    TO              reduce using rule 60 (exp -> exp EQ exp .)
    DOWNTO          reduce using rule 60 (exp -> exp EQ exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    LE              shift and go to state 70

  ! SUM             [ reduce using rule 60 (exp -> exp EQ exp .) ]
  ! SUB             [ reduce using rule 60 (exp -> exp EQ exp .) ]
  ! MUL             [ reduce using rule 60 (exp -> exp EQ exp .) ]
  ! DIV             [ reduce using rule 60 (exp -> exp EQ exp .) ]
  ! LE              [ reduce using rule 60 (exp -> exp EQ exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! GE              [ shift and go to state 71 ]


state 102

    (61) exp -> exp LT exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 61 (exp -> exp LT exp .)
    OR              reduce using rule 61 (exp -> exp LT exp .)
    LT              reduce using rule 61 (exp -> exp LT exp .)
    SEMI_COLON      reduce using rule 61 (exp -> exp LT exp .)
    END             reduce using rule 61 (exp -> exp LT exp .)
    THEN            reduce using rule 61 (exp -> exp LT exp .)
    CLOSE_PAREN     reduce using rule 61 (exp -> exp LT exp .)
    DO              reduce using rule 61 (exp -> exp LT exp .)
    INTEGER         reduce using rule 61 (exp -> exp LT exp .)
    ELSE            reduce using rule 61 (exp -> exp LT exp .)
    SEPARATOR       reduce using rule 61 (exp -> exp LT exp .)
    TO              reduce using rule 61 (exp -> exp LT exp .)
    DOWNTO          reduce using rule 61 (exp -> exp LT exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    NE              shift and go to state 66
    EQ              shift and go to state 67
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71

  ! SUM             [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! SUB             [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! MUL             [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! DIV             [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! NE              [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! EQ              [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! GT              [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! LE              [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! GE              [ reduce using rule 61 (exp -> exp LT exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! LT              [ shift and go to state 68 ]


state 103

    (62) exp -> exp GT exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 62 (exp -> exp GT exp .)
    OR              reduce using rule 62 (exp -> exp GT exp .)
    LT              reduce using rule 62 (exp -> exp GT exp .)
    GT              reduce using rule 62 (exp -> exp GT exp .)
    SEMI_COLON      reduce using rule 62 (exp -> exp GT exp .)
    END             reduce using rule 62 (exp -> exp GT exp .)
    THEN            reduce using rule 62 (exp -> exp GT exp .)
    CLOSE_PAREN     reduce using rule 62 (exp -> exp GT exp .)
    DO              reduce using rule 62 (exp -> exp GT exp .)
    INTEGER         reduce using rule 62 (exp -> exp GT exp .)
    ELSE            reduce using rule 62 (exp -> exp GT exp .)
    SEPARATOR       reduce using rule 62 (exp -> exp GT exp .)
    TO              reduce using rule 62 (exp -> exp GT exp .)
    DOWNTO          reduce using rule 62 (exp -> exp GT exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LE              shift and go to state 70
    GE              shift and go to state 71

  ! SUM             [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! SUB             [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! MUL             [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! DIV             [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! NE              [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! EQ              [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! LE              [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! GE              [ reduce using rule 62 (exp -> exp GT exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]


state 104

    (63) exp -> exp LE exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 63 (exp -> exp LE exp .)
    OR              reduce using rule 63 (exp -> exp LE exp .)
    NE              reduce using rule 63 (exp -> exp LE exp .)
    EQ              reduce using rule 63 (exp -> exp LE exp .)
    LT              reduce using rule 63 (exp -> exp LE exp .)
    GT              reduce using rule 63 (exp -> exp LE exp .)
    LE              reduce using rule 63 (exp -> exp LE exp .)
    GE              reduce using rule 63 (exp -> exp LE exp .)
    SEMI_COLON      reduce using rule 63 (exp -> exp LE exp .)
    END             reduce using rule 63 (exp -> exp LE exp .)
    THEN            reduce using rule 63 (exp -> exp LE exp .)
    CLOSE_PAREN     reduce using rule 63 (exp -> exp LE exp .)
    DO              reduce using rule 63 (exp -> exp LE exp .)
    INTEGER         reduce using rule 63 (exp -> exp LE exp .)
    ELSE            reduce using rule 63 (exp -> exp LE exp .)
    SEPARATOR       reduce using rule 63 (exp -> exp LE exp .)
    TO              reduce using rule 63 (exp -> exp LE exp .)
    DOWNTO          reduce using rule 63 (exp -> exp LE exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63

  ! SUM             [ reduce using rule 63 (exp -> exp LE exp .) ]
  ! SUB             [ reduce using rule 63 (exp -> exp LE exp .) ]
  ! MUL             [ reduce using rule 63 (exp -> exp LE exp .) ]
  ! DIV             [ reduce using rule 63 (exp -> exp LE exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! NE              [ shift and go to state 66 ]
  ! EQ              [ shift and go to state 67 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! LE              [ shift and go to state 70 ]
  ! GE              [ shift and go to state 71 ]


state 105

    (64) exp -> exp GE exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    AND             reduce using rule 64 (exp -> exp GE exp .)
    OR              reduce using rule 64 (exp -> exp GE exp .)
    LT              reduce using rule 64 (exp -> exp GE exp .)
    GT              reduce using rule 64 (exp -> exp GE exp .)
    GE              reduce using rule 64 (exp -> exp GE exp .)
    SEMI_COLON      reduce using rule 64 (exp -> exp GE exp .)
    END             reduce using rule 64 (exp -> exp GE exp .)
    THEN            reduce using rule 64 (exp -> exp GE exp .)
    CLOSE_PAREN     reduce using rule 64 (exp -> exp GE exp .)
    DO              reduce using rule 64 (exp -> exp GE exp .)
    INTEGER         reduce using rule 64 (exp -> exp GE exp .)
    ELSE            reduce using rule 64 (exp -> exp GE exp .)
    SEPARATOR       reduce using rule 64 (exp -> exp GE exp .)
    TO              reduce using rule 64 (exp -> exp GE exp .)
    DOWNTO          reduce using rule 64 (exp -> exp GE exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LE              shift and go to state 70

  ! SUM             [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! SUB             [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! MUL             [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! DIV             [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! NE              [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! EQ              [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! LE              [ reduce using rule 64 (exp -> exp GE exp .) ]
  ! AND             [ shift and go to state 64 ]
  ! OR              [ shift and go to state 65 ]
  ! LT              [ shift and go to state 68 ]
  ! GT              [ shift and go to state 69 ]
  ! GE              [ shift and go to state 71 ]


state 106

    (32) assignstmt -> lvalue ASSIGN exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 32 (assignstmt -> lvalue ASSIGN exp .)
    END             reduce using rule 32 (assignstmt -> lvalue ASSIGN exp .)
    TO              reduce using rule 32 (assignstmt -> lvalue ASSIGN exp .)
    DOWNTO          reduce using rule 32 (assignstmt -> lvalue ASSIGN exp .)
    ELSE            reduce using rule 32 (assignstmt -> lvalue ASSIGN exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 107

    (15) idlist -> idlist SEPARATOR iddec .

    SEMI_COLON      reduce using rule 15 (idlist -> idlist SEPARATOR iddec .)
    SEPARATOR       reduce using rule 15 (idlist -> idlist SEPARATOR iddec .)


state 108

    (13) iddec -> ID ASSIGN exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    SEMI_COLON      reduce using rule 13 (iddec -> ID ASSIGN exp .)
    SEPARATOR       reduce using rule 13 (iddec -> ID ASSIGN exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 109

    (19) procdec -> PROCEDURE ID OPEN_PAREN paramdecslast . CLOSE_PAREN declistlast block SEMI_COLON

    CLOSE_PAREN     shift and go to state 127


state 110

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN . COLON type declistlast block SEMI_COLON

    COLON           shift and go to state 128


state 111

    (24) paramdec -> type paramlist .
    (26) paramlist -> paramlist . SEPARATOR ID

    SEMI_COLON      reduce using rule 24 (paramdec -> type paramlist .)
    CLOSE_PAREN     reduce using rule 24 (paramdec -> type paramlist .)
    SEPARATOR       shift and go to state 129


state 112

    (25) paramlist -> ID .

    SEPARATOR       reduce using rule 25 (paramlist -> ID .)
    SEMI_COLON      reduce using rule 25 (paramlist -> ID .)
    CLOSE_PAREN     reduce using rule 25 (paramlist -> ID .)


state 113

    (23) paramdecs -> paramdecs SEMI_COLON . paramdec
    (24) paramdec -> . type paramlist
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL

    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16

    paramdec                       shift and go to state 130
    type                           shift and go to state 78

state 114

    (71) exp -> ID OPEN_PAREN explist CLOSE_PAREN .

    SUM             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SUB             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    MUL             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DIV             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    AND             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    OR              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    NE              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    EQ              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    LT              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    GT              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    LE              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    GE              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SEMI_COLON      reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    END             reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    THEN            reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    CLOSE_PAREN     reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DO              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    INTEGER         reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    ELSE            reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    SEPARATOR       reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    TO              reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)
    DOWNTO          reduce using rule 71 (exp -> ID OPEN_PAREN explist CLOSE_PAREN .)


state 115

    (73) explist -> explist SEPARATOR . exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    exp                            shift and go to state 131
    lvalue                         shift and go to state 49

state 116

    (30) stmtlist -> stmtlist SEMI_COLON stmt .

    END             reduce using rule 30 (stmtlist -> stmtlist SEMI_COLON stmt .)
    SEMI_COLON      reduce using rule 30 (stmtlist -> stmtlist SEMI_COLON stmt .)


state 117

    (34) stmt -> IF controlifexp THEN block .
    (35) stmt -> IF controlifexp THEN block . ELSE controlelse block

    SEMI_COLON      reduce using rule 34 (stmt -> IF controlifexp THEN block .)
    END             reduce using rule 34 (stmt -> IF controlifexp THEN block .)
    ELSE            shift and go to state 132

  ! ELSE            [ reduce using rule 34 (stmt -> IF controlifexp THEN block .) ]


state 118

    (38) stmt -> PRINT OPEN_PAREN ID CLOSE_PAREN .

    SEMI_COLON      reduce using rule 38 (stmt -> PRINT OPEN_PAREN ID CLOSE_PAREN .)
    END             reduce using rule 38 (stmt -> PRINT OPEN_PAREN ID CLOSE_PAREN .)
    ELSE            reduce using rule 38 (stmt -> PRINT OPEN_PAREN ID CLOSE_PAREN .)


state 119

    (39) stmt -> WHILE controlwhileexp DO block .

    SEMI_COLON      reduce using rule 39 (stmt -> WHILE controlwhileexp DO block .)
    END             reduce using rule 39 (stmt -> WHILE controlwhileexp DO block .)
    ELSE            reduce using rule 39 (stmt -> WHILE controlwhileexp DO block .)


state 120

    (41) stmt -> FOR assignstmt TO controlforupexp . DO block

    DO              shift and go to state 133


state 121

    (43) controlforupexp -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    DO              reduce using rule 43 (controlforupexp -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 122

    (42) stmt -> FOR assignstmt DOWNTO controlfordownexp . DO block

    DO              shift and go to state 134


state 123

    (44) controlfordownexp -> exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    DO              reduce using rule 44 (controlfordownexp -> exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 124

    (45) stmt -> CASE controlcaseexp caseelement END .

    SEMI_COLON      reduce using rule 45 (stmt -> CASE controlcaseexp caseelement END .)
    END             reduce using rule 45 (stmt -> CASE controlcaseexp caseelement END .)
    ELSE            reduce using rule 45 (stmt -> CASE controlcaseexp caseelement END .)


state 125

    (48) caseelement -> caseelement case . COLON caseelementcontrol block SEMI_COLON

    COLON           shift and go to state 135


state 126

    (47) caseelement -> case COLON . caseelementcontrol block SEMI_COLON
    (49) caseelementcontrol -> .

    BEGIN           reduce using rule 49 (caseelementcontrol -> .)
    IF              reduce using rule 49 (caseelementcontrol -> .)
    PRINT           reduce using rule 49 (caseelementcontrol -> .)
    WHILE           reduce using rule 49 (caseelementcontrol -> .)
    FOR             reduce using rule 49 (caseelementcontrol -> .)
    CASE            reduce using rule 49 (caseelementcontrol -> .)
    RETURN          reduce using rule 49 (caseelementcontrol -> .)
    OPEN_PAREN      reduce using rule 49 (caseelementcontrol -> .)
    REALNUMBER      reduce using rule 49 (caseelementcontrol -> .)
    INTEGER         reduce using rule 49 (caseelementcontrol -> .)
    TRUE            reduce using rule 49 (caseelementcontrol -> .)
    FALSE           reduce using rule 49 (caseelementcontrol -> .)
    ID              reduce using rule 49 (caseelementcontrol -> .)

    caseelementcontrol             shift and go to state 136

state 127

    (19) procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN . declistlast block SEMI_COLON
    (2) declistlast -> . declist
    (3) declistlast -> .
    (4) declist -> . dec
    (5) declist -> . declist dec
    (6) dec -> . vardec
    (7) dec -> . procdec
    (8) dec -> . funcdec
    (16) vardec -> . type idlist SEMI_COLON
    (19) procdec -> . PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
    (21) funcdec -> . funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL
    (20) funcname -> . FUNCTION ID

    BEGIN           reduce using rule 3 (declistlast -> .)
    IF              reduce using rule 3 (declistlast -> .)
    PRINT           reduce using rule 3 (declistlast -> .)
    WHILE           reduce using rule 3 (declistlast -> .)
    FOR             reduce using rule 3 (declistlast -> .)
    CASE            reduce using rule 3 (declistlast -> .)
    RETURN          reduce using rule 3 (declistlast -> .)
    OPEN_PAREN      reduce using rule 3 (declistlast -> .)
    REALNUMBER      reduce using rule 3 (declistlast -> .)
    INTEGER         reduce using rule 3 (declistlast -> .)
    TRUE            reduce using rule 3 (declistlast -> .)
    FALSE           reduce using rule 3 (declistlast -> .)
    ID              reduce using rule 3 (declistlast -> .)
    PROCEDURE       shift and go to state 12
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16
    FUNCTION        shift and go to state 17

    declistlast                    shift and go to state 137
    declist                        shift and go to state 6
    dec                            shift and go to state 7
    vardec                         shift and go to state 8
    procdec                        shift and go to state 9
    funcdec                        shift and go to state 10
    type                           shift and go to state 11
    funcname                       shift and go to state 13

state 128

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON . type declistlast block SEMI_COLON
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL

    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16

    type                           shift and go to state 138

state 129

    (26) paramlist -> paramlist SEPARATOR . ID

    ID              shift and go to state 139


state 130

    (23) paramdecs -> paramdecs SEMI_COLON paramdec .

    SEMI_COLON      reduce using rule 23 (paramdecs -> paramdecs SEMI_COLON paramdec .)
    CLOSE_PAREN     reduce using rule 23 (paramdecs -> paramdecs SEMI_COLON paramdec .)


state 131

    (73) explist -> explist SEPARATOR exp .
    (53) exp -> exp . SUM exp
    (54) exp -> exp . SUB exp
    (55) exp -> exp . MUL exp
    (56) exp -> exp . DIV exp
    (57) exp -> exp . AND exp
    (58) exp -> exp . OR exp
    (59) exp -> exp . NE exp
    (60) exp -> exp . EQ exp
    (61) exp -> exp . LT exp
    (62) exp -> exp . GT exp
    (63) exp -> exp . LE exp
    (64) exp -> exp . GE exp

    CLOSE_PAREN     reduce using rule 73 (explist -> explist SEPARATOR exp .)
    SEPARATOR       reduce using rule 73 (explist -> explist SEPARATOR exp .)
    SUM             shift and go to state 60
    SUB             shift and go to state 61
    MUL             shift and go to state 62
    DIV             shift and go to state 63
    AND             shift and go to state 64
    OR              shift and go to state 65
    NE              shift and go to state 66
    EQ              shift and go to state 67
    LT              shift and go to state 68
    GT              shift and go to state 69
    LE              shift and go to state 70
    GE              shift and go to state 71


state 132

    (35) stmt -> IF controlifexp THEN block ELSE . controlelse block
    (37) controlelse -> .

    BEGIN           reduce using rule 37 (controlelse -> .)
    IF              reduce using rule 37 (controlelse -> .)
    PRINT           reduce using rule 37 (controlelse -> .)
    WHILE           reduce using rule 37 (controlelse -> .)
    FOR             reduce using rule 37 (controlelse -> .)
    CASE            reduce using rule 37 (controlelse -> .)
    RETURN          reduce using rule 37 (controlelse -> .)
    OPEN_PAREN      reduce using rule 37 (controlelse -> .)
    REALNUMBER      reduce using rule 37 (controlelse -> .)
    INTEGER         reduce using rule 37 (controlelse -> .)
    TRUE            reduce using rule 37 (controlelse -> .)
    FALSE           reduce using rule 37 (controlelse -> .)
    ID              reduce using rule 37 (controlelse -> .)

    controlelse                    shift and go to state 140

state 133

    (41) stmt -> FOR assignstmt TO controlforupexp DO . block
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    assignstmt                     shift and go to state 22
    block                          shift and go to state 141
    stmt                           shift and go to state 21
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 134

    (42) stmt -> FOR assignstmt DOWNTO controlfordownexp DO . block
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    assignstmt                     shift and go to state 22
    block                          shift and go to state 142
    stmt                           shift and go to state 21
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 135

    (48) caseelement -> caseelement case COLON . caseelementcontrol block SEMI_COLON
    (49) caseelementcontrol -> .

    BEGIN           reduce using rule 49 (caseelementcontrol -> .)
    IF              reduce using rule 49 (caseelementcontrol -> .)
    PRINT           reduce using rule 49 (caseelementcontrol -> .)
    WHILE           reduce using rule 49 (caseelementcontrol -> .)
    FOR             reduce using rule 49 (caseelementcontrol -> .)
    CASE            reduce using rule 49 (caseelementcontrol -> .)
    RETURN          reduce using rule 49 (caseelementcontrol -> .)
    OPEN_PAREN      reduce using rule 49 (caseelementcontrol -> .)
    REALNUMBER      reduce using rule 49 (caseelementcontrol -> .)
    INTEGER         reduce using rule 49 (caseelementcontrol -> .)
    TRUE            reduce using rule 49 (caseelementcontrol -> .)
    FALSE           reduce using rule 49 (caseelementcontrol -> .)
    ID              reduce using rule 49 (caseelementcontrol -> .)

    caseelementcontrol             shift and go to state 143

state 136

    (47) caseelement -> case COLON caseelementcontrol . block SEMI_COLON
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 144
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 137

    (19) procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast . block SEMI_COLON
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 145
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 138

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type . declistlast block SEMI_COLON
    (2) declistlast -> . declist
    (3) declistlast -> .
    (4) declist -> . dec
    (5) declist -> . declist dec
    (6) dec -> . vardec
    (7) dec -> . procdec
    (8) dec -> . funcdec
    (16) vardec -> . type idlist SEMI_COLON
    (19) procdec -> . PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON
    (21) funcdec -> . funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON
    (9) type -> . INT
    (10) type -> . REAL
    (11) type -> . BOOL
    (20) funcname -> . FUNCTION ID

    BEGIN           reduce using rule 3 (declistlast -> .)
    IF              reduce using rule 3 (declistlast -> .)
    PRINT           reduce using rule 3 (declistlast -> .)
    WHILE           reduce using rule 3 (declistlast -> .)
    FOR             reduce using rule 3 (declistlast -> .)
    CASE            reduce using rule 3 (declistlast -> .)
    RETURN          reduce using rule 3 (declistlast -> .)
    OPEN_PAREN      reduce using rule 3 (declistlast -> .)
    REALNUMBER      reduce using rule 3 (declistlast -> .)
    INTEGER         reduce using rule 3 (declistlast -> .)
    TRUE            reduce using rule 3 (declistlast -> .)
    FALSE           reduce using rule 3 (declistlast -> .)
    ID              reduce using rule 3 (declistlast -> .)
    PROCEDURE       shift and go to state 12
    INT             shift and go to state 14
    REAL            shift and go to state 15
    BOOL            shift and go to state 16
    FUNCTION        shift and go to state 17

    funcname                       shift and go to state 13
    type                           shift and go to state 11
    declistlast                    shift and go to state 146
    declist                        shift and go to state 6
    dec                            shift and go to state 7
    vardec                         shift and go to state 8
    procdec                        shift and go to state 9
    funcdec                        shift and go to state 10

state 139

    (26) paramlist -> paramlist SEPARATOR ID .

    SEPARATOR       reduce using rule 26 (paramlist -> paramlist SEPARATOR ID .)
    SEMI_COLON      reduce using rule 26 (paramlist -> paramlist SEPARATOR ID .)
    CLOSE_PAREN     reduce using rule 26 (paramlist -> paramlist SEPARATOR ID .)


state 140

    (35) stmt -> IF controlifexp THEN block ELSE controlelse . block
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 147
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 141

    (41) stmt -> FOR assignstmt TO controlforupexp DO block .

    SEMI_COLON      reduce using rule 41 (stmt -> FOR assignstmt TO controlforupexp DO block .)
    END             reduce using rule 41 (stmt -> FOR assignstmt TO controlforupexp DO block .)
    ELSE            reduce using rule 41 (stmt -> FOR assignstmt TO controlforupexp DO block .)


state 142

    (42) stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .

    SEMI_COLON      reduce using rule 42 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)
    END             reduce using rule 42 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)
    ELSE            reduce using rule 42 (stmt -> FOR assignstmt DOWNTO controlfordownexp DO block .)


state 143

    (48) caseelement -> caseelement case COLON caseelementcontrol . block SEMI_COLON
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 148
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 144

    (47) caseelement -> case COLON caseelementcontrol block . SEMI_COLON

    SEMI_COLON      shift and go to state 149


state 145

    (19) procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block . SEMI_COLON

    SEMI_COLON      shift and go to state 150


state 146

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast . block SEMI_COLON
    (27) block -> . BEGIN stmtlist END
    (28) block -> . stmt
    (33) stmt -> . assignstmt
    (34) stmt -> . IF controlifexp THEN block
    (35) stmt -> . IF controlifexp THEN block ELSE controlelse block
    (38) stmt -> . PRINT OPEN_PAREN ID CLOSE_PAREN
    (39) stmt -> . WHILE controlwhileexp DO block
    (41) stmt -> . FOR assignstmt TO controlforupexp DO block
    (42) stmt -> . FOR assignstmt DOWNTO controlfordownexp DO block
    (45) stmt -> . CASE controlcaseexp caseelement END
    (51) stmt -> . RETURN exp
    (52) stmt -> . exp
    (32) assignstmt -> . lvalue ASSIGN exp
    (53) exp -> . exp SUM exp
    (54) exp -> . exp SUB exp
    (55) exp -> . exp MUL exp
    (56) exp -> . exp DIV exp
    (57) exp -> . exp AND exp
    (58) exp -> . exp OR exp
    (59) exp -> . exp NE exp
    (60) exp -> . exp EQ exp
    (61) exp -> . exp LT exp
    (62) exp -> . exp GT exp
    (63) exp -> . exp LE exp
    (64) exp -> . exp GE exp
    (65) exp -> . OPEN_PAREN exp CLOSE_PAREN
    (66) exp -> . REALNUMBER
    (67) exp -> . INTEGER
    (68) exp -> . TRUE
    (69) exp -> . FALSE
    (70) exp -> . lvalue
    (71) exp -> . ID OPEN_PAREN explist CLOSE_PAREN
    (31) lvalue -> . ID

    BEGIN           shift and go to state 20
    IF              shift and go to state 23
    PRINT           shift and go to state 24
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    CASE            shift and go to state 28
    RETURN          shift and go to state 29
    OPEN_PAREN      shift and go to state 25
    REALNUMBER      shift and go to state 32
    INTEGER         shift and go to state 33
    TRUE            shift and go to state 34
    FALSE           shift and go to state 35
    ID              shift and go to state 18

    block                          shift and go to state 151
    stmt                           shift and go to state 21
    assignstmt                     shift and go to state 22
    exp                            shift and go to state 30
    lvalue                         shift and go to state 31

state 147

    (35) stmt -> IF controlifexp THEN block ELSE controlelse block .

    SEMI_COLON      reduce using rule 35 (stmt -> IF controlifexp THEN block ELSE controlelse block .)
    END             reduce using rule 35 (stmt -> IF controlifexp THEN block ELSE controlelse block .)
    ELSE            reduce using rule 35 (stmt -> IF controlifexp THEN block ELSE controlelse block .)


state 148

    (48) caseelement -> caseelement case COLON caseelementcontrol block . SEMI_COLON

    SEMI_COLON      shift and go to state 152


state 149

    (47) caseelement -> case COLON caseelementcontrol block SEMI_COLON .

    END             reduce using rule 47 (caseelement -> case COLON caseelementcontrol block SEMI_COLON .)
    INTEGER         reduce using rule 47 (caseelement -> case COLON caseelementcontrol block SEMI_COLON .)


state 150

    (19) procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .

    PROCEDURE       reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    INT             reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    REAL            reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    BOOL            reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    FUNCTION        reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    BEGIN           reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    IF              reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    PRINT           reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    WHILE           reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    FOR             reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    CASE            reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    RETURN          reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    REALNUMBER      reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    INTEGER         reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    TRUE            reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    FALSE           reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)
    ID              reduce using rule 19 (procdec -> PROCEDURE ID OPEN_PAREN paramdecslast CLOSE_PAREN declistlast block SEMI_COLON .)


state 151

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block . SEMI_COLON

    SEMI_COLON      shift and go to state 153


state 152

    (48) caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .

    END             reduce using rule 48 (caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .)
    INTEGER         reduce using rule 48 (caseelement -> caseelement case COLON caseelementcontrol block SEMI_COLON .)


state 153

    (21) funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .

    PROCEDURE       reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    INT             reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    REAL            reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    BOOL            reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    FUNCTION        reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    BEGIN           reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    IF              reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    PRINT           reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    WHILE           reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    FOR             reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    CASE            reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    RETURN          reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    OPEN_PAREN      reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    REALNUMBER      reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    INTEGER         reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    TRUE            reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    FALSE           reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)
    ID              reduce using rule 21 (funcdec -> funcname OPEN_PAREN paramdecslast CLOSE_PAREN COLON type declistlast block SEMI_COLON .)

